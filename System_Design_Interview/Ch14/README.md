# 유튜브 설계

## 문제 이해 및 설계 범위 확정

* 요구 기능
  * 빠른 비디오 업로드
  * 원활한 비디오 재생
  * 재생 품질 선택 기능
  * 낮은 인프라 비용
  * 높은 가용성과 규모 확장성, 안정성
  * 지원 클라이언트 : 모바일 앱, 웹 브라우저, 스마트 TV

### 개략적 규모 추정

* 일간 능동 사용자(DAU: Daily Active User) : 5백만
* 한 사용자는 하루에 평균 5개의 비디오 시청
* 10% 사용자가 하루에 1개의 비디오 업로드
* 비디오 평균 크기는 300MB
* 비디오 저장을 위해 매일 새로 요구되는 저장 용량 = 5백만 * 10% * 300MB = 150TB
* CDN 비용
  * 클라우드 CDN을 통해 비디오 서비스 시 CDN에서 나가는 데이터의 양에 따라 과금한다.
  * 아마존의 클라우드프론트를 CDN 솔루션으로 사용할 경우, 100% 트래픽이 미국에서 발생한다고 가정하면 1GB당 0.02달러의 요금 발생
  * 매일 발생하는 요금 = 5백만 * 5개의 비디오 (시청) * 0.3GB * 0.02달러 = 15만 달러
  * CDN을 이용해 비디오를 서비스하면 비용이 엄청나다는 것을 알 수 있다.

## 개략적 설계안 제시 및 동의 구하기

* CDN과 BLOB 저장소를 사용할 때 기존 클라우드 서비스를 활용하는 이유
  * 시스템 설계 면접은 적절한 기술을 골라 설계를 마치는 것이, 기술 각각이 어떻게 동작하는지 상세히 설명하는 것보다 중요하다.
  * 규모 확장이 쉬운 BLOB 저장소나 CDN을 만드는 것은 복잡하고 많은 비용이 든다.
* 전체적인 시스템 구조
  * 단말
  * CDN : 비디오 저장 장소로 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어진다.
  * API 서버 : 비디오 스트리밍을 제외한 모든 요청을 처리한다.
    * 피드 추천, 비디오 업로드 URL 생성, 메타데이터 데이터베이스와 캐시 갱신, 사용자 가입 등

### 비디오 업로드 절차

* 구성 컴포넌트
  * 사용자
  * 로드밸런서 : API 서버 각각으로 고르게 요청을 분산
  * API 서버 : 비디오 스트리밍을 제외한 다른 모든 요청 처리
  * 메타데이터 데이터베이스 : 비디오와 메타데이터 보관
    * 샤딩과 다중화 적용해 성능 및 가용성 요구사항 충족
  * 메타데이터 캐시 : 성능을 높이기 위해 비디오 메타데이터와 사용자 객체 캐시
  * 원본 저장소 : 원본 비디오를 보관할 대형 이진 파일 저장소(BLOB : Binary Large Object storage) 시스템
  * 트랜스코딩 서버 : 비디오 트랜스코딩(인코딩)을 담당
    * 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요
  * 트랜스코딩 비디오 저장소 : 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소
  * CDN : 비디오 캐시 담당
    * 사용자가 재생 버튼을 누르면 비디오 스트리밍은 CDN을 통해 이루어진다.
  * 트랜스코딩 완료 큐 : 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐
  * 트랜스코딩 완료 핸들러 : 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타데이터 캐시와 데이터베이스를 갱신할 작업 서버들
* 비디오 업로드 처리 절차
  * 비디오 업로드와 비디오 메타데이터 갱신이 병렬적으로 수행된다.
* 비디오 업로드
  * 비디오를 원본 저장소에 업로드
  * 트랜스코딩 서버가 원본 저장소에서 해당 비디오를 가져와 트랜스코딩 시작
  * 트랜스코딩 완료 후 두 절차가 병렬적으로 수행
    * 완료된 비디오를 트랜스코딩 비디오 저장소에 업로드
      * 트랜스코딩이 끝난 비디오를 CDN에 올린다.
    * 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 삽입
      * 완료 핸들러가 이벤트 데이터를 큐에서 꺼낸다.
      * 완료 핸들러가 메타데이터 데이터베이스와 캐시를 갱신한다.
  * API 서버가 단말에게 비디오 업로드가 끝나서 스트리밍 준비가 되었음을 알림
* 메타데이터 갱신
  * 원본 저장소에 파일이 업로드되는 동안, 단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 전송
  * 메타데이터 정보에는 파일 이름, 크기, 포맷 등의 정보가 포함됨
  * API 서버는 이 정보로 메타데이터 캐시와 데이터베이스를 업데이트

### 비디오 스트리밍 절차

* 다운로드 vs 스트리밍
  * 다운로드 : 비디오를 단말로 내려 받는 것
  * 스트리밍 : 장치가 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송받아 영상을 재생하는 것
* 스트리밍 프로토콜
  * 비디오 스트리밍을 위해 데이터 전송 시 쓰이는 표준화된 통신 방법
  * MPEG-DASH, 애플 HLS, Microsoft Smooth Streaming, Adobe HTTP Dynamic Streaming 등이 있다.
  * 프로토콜마다 지원하는 비디오 인코딩이 다르고 플레이어도 다르다.
  * 비디오 스트리밍 설계 시 서비스의 용례에 맞는 프로토콜을 잘 골라야 한다.
* 스트리밍 절차
  * 사용자의 단말에서 가장 가까운 CDN 엣지 서버에서 바로 스트리밍된다.
  * 전송지연이 아주 낮다.

## 상세 설계

### 비디오 트랜스코딩

* 비디오가 여러 단말에서 순조롭게 재생되려면 해당 단말과 호환되는 비트레이트와 포맷으로 저장해야 한다.
* 비트레이트(bitrate) : 비디오 구성 비트가 얼마나 빨리 처리되어야 하는지를 나타내는 단위
  * 비트레이트가 높을수록 일반적으로 고화질 비디오
  * 비트레이트가 높은 비디오 스트림을 정상 재생하려면 높은 성능의 컴퓨팅 파워와 빠른 인터넷 회선 속도가 필요
* 비디오 트랜스코딩이 필요한 이유
  * 원본 비디오는 저장 공간을 많이 차지
  * 대부분의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원
  * 네트워크 대역폭에 따라 다른 화질의 비디오를 전송
  * 모바일 단말의 경우 네트워크 상황이 매번 달라질 수 있어 비디오 화질을 자동 혹은 수동으로 변경할 수 있어야 함
* 인코딩 포맷
  * 컨테이너 : 비디오 파일, 오디오, 메타데이터를 담는 바구니
    * 컨테이너 포맷은 .avi, .mov, .mp4 같은 파일 확장자를 통해 알 수 있다.
  * 코덱 : 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘
    * H.264, VP9, HEVC 등

### DAG 모델

* 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하면서 처리 과정의 병렬성 향상을 위해 적절한 수준의 추상화를 도입한다.
  * 클라이언트 프로그래머로 하여금 실행할 작업을 직접 정의할 수 있도록 해야 한다.
* DAG를 통해 작업을 단계별로 배열할 수 있도록 해 작업들이 순차적으로 또는 병렬적으로 실행될 수 있도록 한다.
* DAG 구조
  * 비디오
    * 검사 : 종은 품질의 비디오인지, 손상은 없는지 확인하는 작업
    * 비디오 인코딩 : 비디오를 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩하는 작업
    * 섬네일 : 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지로 섬네일 제작 작업
    * 워터마크 : 비디오에 대한 식별정보를 이미지 위에 오버레이 형태로 띄워 표시하는 작업
  * 오디오
    * 오디오 인코딩
  * 메타데이터
  * 비디오와 오디오 작업이 모두 완료되면 병합한다.

### 비디오 트랜스코딩 아키텍처

* 주요 컴포넌트 : 전처리기, DAG 스케쥴러, 자원 관리자, 작업 실행 서버, 임시 저장소
* 전처리기
  * 비디오 분할
    * 비디오 스트밀을 GOP(Group of Pictures)라 불리는 단위로 쪼갠다.
    * GOP : 특정 순서로 배열된 프레임 그룹으로 독립적으로 재생이 가능하며, 길이는 보통 몇 초 정도다.
    * 오래된 단말이나 브라우저는 GOP 단위의 비디오 분할을 지원하지 않는데, 그런 단말의 경우 전처리기가 비디오 분할을 대신한다.
  * DAG 생성
    * 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 만들어낸다.
  * 데이터 캐시
    * 안정성을 높이기 위해 GOP와 메타데이터를 임시 저장소에 보관한다.
    * 비디오 인코딩이 실패하면 보관된 데이터를 활용해 인코딩을 재개한다.
* DAG 스케쥴러
  * DAG 그래프를 몇 개 단계로 분할한 다음 그 각각을 자원 관리자의 작업 큐에 집어넣는다.
* 자원 관리자
  * 자원 배분을 효과적으로 수행한다.
  * 세 개의 큐와 작업 스케쥴러로 구성
    * 작업 큐 : 실행할 작업이 보관되어 있는 우선순위 큐
    * 작업 서버 큐 : 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐
    * 실행 큐 : 현재 실행 중인 작업과 작업 서버 정보가 보관되어 있는 큐
    * 작업 스케쥴러 : 최적의 작업/서버 조합을 골라 해당 작업 서버가 작업을 수행하도록 지시하는 역할
  * 동작 방식
    * 작업 큐에서 가장 높은 우선순위의 작업을 꺼낸다.
    * 해당 작업을 실행하기 적합한 작업 서버를 고른다.
    * 해당 작업 서버에게 작업 실행을 지시한다.
    * 해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 실행 큐에 넣는다.
    * 작업이 완료되면 해당 작업을 실행 큐에서 제거한다.
* 작업 서버
  * DAG에 정의된 작업을 수행한다.
  * 작업 종류에 따라 작업 서버도 구분하여 관리한다.
* 임시 저장소
  * 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 여러 저장소 시스템을 활용할 수 있다.
  * 메타데이터의 경우 작업 서버가 빈번히 참조하고, 크기가 작으므로 메모리에 캐시해 둔다.
  * 비디오/오디오 데이터의 경우 BLOB 저장소에 둔다.
  * 임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제

### 시스템 최적화

* 비디오 병렬 업로드
  * 작은 GOP들로 분할해 병렬적으로 업로드한다.
* 업로드 센터를 사용자 근거리에 지정
  * 업로드 센터를 여러 곳에 둔다.
  * CDN을 업로드 센터로 이용한다.
* 모든 절차를 병렬화
  * 메시지 큐를 도입해 각 과정이 끝나기를 기다리지 않고 메시지 큐에 보관된 이벤트 각각을 병렬적으로 처리한다.
* 미리 사인된 업로드 URL
  * 허가받은 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해 미리 사인된 업로드 URL을 이용한다.
  * 업로드 절차
    * 클라이언트는 HTTP 서버에 POST 요청을 해 미리 사인된 URL을 받는다.
      * 해당 URL이 가리키는 객체에 대한 접근 권한이 이미 주어져 있는 상태
    * API 서버는 미리 사인된 URL을 돌려준다.
    * 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.
* 비디오 보호
  * 디지털 저작권 관리 시스템 도입 : 애플의 페이플레이, 구글의 와이드바인, 마이크로소프트의 플레이레디
  * AES 암호화 : 비디오를 암호화하고 접근 권한을 설정하는 방식으로 허락된 사용자가 재생 시에만 복호화한다.
  * 워터마크
* 비용 최적화
  * 인기 비디오는 CDN을 통해 재생하고 다른 비디오는 비디오 서버를 통해 재생한다.
  * 인기가 별로 없는 비디오는 인코딩할 필요가 없을 수도 있다.
  * 어떤 비디오는 특정 지역에서만 인기가 높아 다른 지역에 옮길 필요가 없다.
  * CDN을 직접 구축하고 인터넷 서비스 제공자와 제휴한다.

### 오류 처리

* 회복 가능 오류
  * 몇 번 재시도하면 해결되는 오류
  * 계속해서 실패하고 복구가 어려운 경우 적절한 오류 코드를 클라이언트에게 반환
* 회복 불가능 오류
  * 해당 비디오에 대한 작업을 중지하고 클라이언트에게 적절한 오류 코드 반환
* 오류의 전형적 해결 방법
  * 업로드, 트랜스코딩 오류 : 재시도
  * 비디오 분할 오류 : 전체 비디오를 서버로 전송하고 서버가 비디오 분할을 처리하도록 함
  * 전처리 오류 : DAG 그래프 재생성
  * DAG 스케쥴러 오류 : 작업을 재스케쥴링
  * 자원 관리자 큐에 장애 발생 : 사본을 이용
  * 작업 서버 장애 : 다른 서버에서 해당 작업 재시도
  * API 서버 장애 : 무상태 서버이므로 신규 요청은 다른 API 서버로 우회
  * 메타데이터 캐시 서버 장애 : 데이터가 다중화되어 있으므로 다른 노드에서 데이터를 가져올 수 있음
  * 메타데이터 데이터베이스 서버 장애 : 주 서버 장애 발생 시 부 서버 중 하나를 주 서버로 교체하고, 부 서버 장애 발생 시 다른 부 서버를 통해 읽기 연산 처리

## 마무리

* 추가 논의 사항
  * API 계층의 규모 확장성 확보 방안 : 무상태 서버이므로 수평적 규모 확장 가능
  * 데이터베이스 계층의 규모 확장성 확보 방안 : 다중화, 샤딩
  * 라이브 스트리밍
    * 비디오를 실시간으로 녹화하고 방송하는 절차
    * 응답지연이 좀더 낮아야 함 -> 스트리밍 프로토콜 선정에 유의
    * 작은 단위의 데이터를 실시간으로 빨리 처리해야 하므로 병렬화 필요성은 감소
    * 너무 많은 시간이 걸리는 오류 처리 방법은 다른 방법으로 교체
  * 비디오 삭제
