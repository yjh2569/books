# 사용자 수에 따른 규모 확장성

### 사용자 요청 처리 흐름

* 사용자가 도메인 이름을 이용해 웹사이트에 접속한다.
  * DNS에 질의해 도메인 이름을 IP 주소로 변환하는 과정이 필요하다.
  * DNS는 보통 제3사업자가 제공하는 유료 서비스를 이용한다.
* DNS 조회 결과로 IP 주소가 반환된다.
* 해당 IP 주소로 HTTP 요청을 전달한다.
* 요청 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

### 요청 단말

* 웹 어플리케이션
  * 서버 구현용 언어 : 비즈니스 로직, 데이터 저장 등을 처리하고, 자바나 파이썬 등이 있다.
  * 클라이언트 구현용 언어 : 프레젠테이션을 위한 언어로, HTML, JS 등이 있다.
* 모바일 앱
  * 모바일 앱과 웹 서버 간 통신을 위해서 HTTP 프로토콜을 이용한다.
  * 응답 데이터는 보통 JSON 형태로 전달된다.

### 데이터베이스

* 관계형 데이터베이스
  * 자료를 테이블과 열, 칼럼으로 표현한다.
  * 여러 테이블에 있는 데이터를 그 관계에 따라 join이 가능하다.
  * MySQL, 오라클 데이터베이스, PostgreSQL 등
* 비관계형 데이터베이스
  * NoSQL라고도 한다.
  * 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나눌 수 있다.
  * 일반적으로 join 연산을 지원하지 않는다.
* 비관계형 데이터베이스가 적합한 경우
  * 아주 짧은 응답 지연시간(latency)이 요구되는 경우
  * 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아닌 경우
  * 데이터를 직렬화하거나 역직렬화할 수 있기만 하면 되는 경우
  * 아주 많은 양의 데이터를 저장해야 하는 경우

## 수직적 규모 확장 VS 수평적 규모 확장

* 수직적 규모 확장(scale up)
  * 서버에 고사양 자원을 추가하는 행위
  * 더 좋은 CPU, 더 많은 RAM 등을 추가하는 경우
* 수평적 규모 확장(scale out)
  * 더 많은 서버를 추가해 성능을 개선하는 행위
* 수직적 규모 확장의 단점
  * 한계가 존재
  * 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안이 없음 → 서버 장애 발생 시 웹 사이트 또는 앱이 완전히 중단된다.
* 따라서 대규모 애플리케이션 지원 시 수평적 규모 확장법을 사용한다.

### 로드밸런서

* 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산한다.
* 사용자는 로드밸런서의 public IP address로 접속하고, 서버 간 통신에는 private IP address를 사용한다.
  * 따라서 서버 내 IP 관련 보안 문제도 해결할 수 있다.
* 로드밸런서가 추가됨으로써 여러 개의 웹 서버를 추가하면 failover 해소 및 가용성(availability) 향상의 효과를 얻을 수 있다.
  * 하나의 서버가 다운되어도 다른 서버에 트래픽을 전달하면 웹 사이트 전체가 다운되는 일을 막을 수 있다.
  * 로드밸런서를 통해 하나의 서버에 과도하게 트래픽이 몰리는 것을 막을 수 있다.

### 데이터베이스 다중화

* 데이터베이스 간의 주-부 관계를 설정하고 데이터 원본은 주 데이터베이스에, 사본은 부 데이터베이스에 저장하는 방식
* 쓰기 연산(insert, update, delete 등)는 주 데이터베이스에서만 지원하고, 부 데이터베이스는 주 데이터베이스로부터 사본을 전달받아 읽기 연산만 지원한다.
  * 읽기 연산이 쓰기 연산에 비해 훨씬 많기 때문에 부 데이터베이스의 수가 주 데이터베이스의 수보다 많다.
* 데이터베이스 다중화의 효과
  * 더 나은 성능
    * 쓰기 연산과 읽기 연산이 분산되어 병렬로 처리할 수 있는 query 수가 증가한다.
  * 안전성(reliability)
    * 데이터베이스 서버 일부가 파괴되어도 데이터를 여러 장소에 다중화시켜 놓으면 데이터를 보존할 수 있다.
  * 가용성(availability)
    * 데이터를 여러 지역에 복제해 둠으로써, 한 데이터베이스 서버에 장애가 생겨도 다른 데이터베이스 서버에서 데이터를 가져와 계속 서비스할 수 있다.
* 데이터베이스 서버 중 하나가 다운되는 경우
  * 부 데이터베이스 서버가 다운되는 경우
    * 읽기 연산은 한시적으로 주 데이터베이스 또는 다른 부 데이터베이스 중 하나가 담당한다.
    * 새로운 부 데이터베이스 서버가 장애 서버를 대체한다.
  * 주 데이터베이스 서버가 다운되는 경우
    * 부 데이터베이스 서버 중 하나가 새로운 주 서버가 되어 모든 쓰기 연산은 일시적으로 새로운 주 서버에서 실행된다.
    * 다만, 부 데이터베이스 서버에 보관된 데이터가 최신 상태가 아닐 수 있으므로, 없는 데이터는 복구 스크립트를 통해 추가해야 한다.
    * 다중 마스터나 원형 다중화 방식도 존재한다.

## 캐시

### 캐시 계층

* 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.
* 읽기 주도형 캐시 전략(read-through caching strategy)
  * 요청을 받은 웹 서버는 캐시에 응답할 데이터가 있는지 확인한다.
  * 만약 캐시에 원하는 데이터가 저장되어 있으면 해당 데이터를 바로 클라이언트에 반환하고, 그렇지 않으면 데이터베이스에서 찾아서 캐시에 저장한다.

### 캐시 사용 시 유의할 점

* 캐시 사용 상황
  * 데이터 갱신은 자주 일어나지 않지만 참조가 빈번할 때
* 캐시에 저장할 데이터
  * 캐시는 휘발성 메모리에 데이터를 저장하므로 영속적으로 보관할 데이터는 캐시에 저장해서는 안 된다.
* 캐시 만료 기한
  * 만료 기한이 짧으면 데이터베이스 접근이 많아지고, 만료 기한이 길면 원본과 차이가 날 가능성이 높아진다.
* 일관성 유지
  * 데이터 저장소의 원본과 캐시 내의 사본이 같아야 한다.
  * 만약 저장소의 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션으로 처리되지 않으면 이 일관성은 깨질 수 있다.
* 장애 대처
  * 캐시 서버를 한 대만 두면 해당 서버는 단일 장애 지점(SPOF)가 될 가능성이 있다.
    * SPOF(Single Point of Failure) : 장애로 인해 전체 시스템의 동작을 중단시킬 수 있는 지점
  * 따라서 SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시커야 한다.
* 캐시 메모리 크기
  * 캐시 메모리가 작으면 데이터가 자주 캐시에서 밀러나(eviction) 캐시의 성능이 떨어진다.
  * 따라서 캐시 메모리를 과할당한다.
* 캐시 데이터 방출 정책
  * 캐시가 꽉 찼을 때 추가로 캐시에 데이터를 넣으려면 기존 데이터를 내보내야 한다.
  * LRU, LFU, FIFO 등이 있다.

## 콘텐츠 전송 네트워크(CDN)

* 정적 콘텐츠를 전송하는데 쓰이는, 여러 지역에 분산된 서버의 네트워크
* 이미지, 비디오, CSS, JS 파일 등을 캐시할 수 있다.
* CDN 동작 방식
  * 사용자가 정적 컨텐츠에 URL(CDN 서비스 사업자가 제공)을 통해 접근한다.
  * CDN 서버의 캐시에 해당 이미지가 없으면 서버는 원본 서버에 요청해 파일을 가져온다.
    * 원본 서버는 웹 서버 또는 아마존 S3 같은 온라인 저장소다.
  * 원본 서버가 파일을 CDN 서버에 반환한다.
    * 응답의 HTTP 헤더에 TTL 값이 들어있다.
  * CDN 서버는 파일을 캐시하고 사용자에게 반환한다.
    * 해당 정적 컨텐츠는 TTL에 명시된 시간이 끝날 때까지 캐시된다.

### CDN 사용 시 고려 사항

* 비용
  * CDN은 보통 제3사업자에 의해 운영되고, CDN으로 출입하는 데이터 전송 양에 따라 요금이 발생한다.
  * 따라서 자주 사용하지 않는 컨텐츠는 CDN에 넣지 않는다.
* 적절한 만료 시한 설정
  * 만료 기한이 너무 길면 컨텐츠의 신선도가 떨어지고, 너무 짧으면 원본 서버에 빈번히 접속하게 된다.
* CDN 장애에 대한 대처 방안
  * CDN에 장애가 발생한 경우 해당 문제를 감지해 원본 서버로부터 직접 컨텐츠를 가져오도록 클라이언트를 구성해야 한다.
* 컨텐츠 무효화 방법
  * 아직 만료되지 않은 컨텐츠라도 아래 방법 중 하나를 쓰면 CDN에서 제거할 수 있다.
    * CDN 서비스 사업자가 제공하는 API를 이용해 컨텐츠 무효화
    * 컨텐츠의 다른 버전을 서비스하도록 object versioning 이용
      * 컨텐츠의 새로운 버전을 지정하려면 URL 마지막에 버전 번호를 인자로 주면 된다.
      * 예를 들어, image.png?v=2와 같이 버전 번호를 줄 수 있다.

## 무상태(stateless) 웹 계층

### 상태 정보 의존적인 아키텍처

* 상태 정보를 보관하는 서버는 클라이언트 정보(상태)를 유지해 요청들 사이에서 공유되도록 한다.
* 이로 인해 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.
  * 로드밸런서는 이를 지원하기 위해 고정 세션이라는 기능을 제공하고 있으나, 이로 인해 로드밸런서에 부담을 주고 로드밸런서 뒷단에 서버 추가 및 제거도 어려워진다.

### 무상태 아키텍처

* 상태 정보를 공유 저장소에 저장함으로써 웹 서버로부터 분리한다.
  * 따라서 사용자의 HTTP 요청을 어떤 웹 서버로도 전달할 수 있다.
  * 이러한 구조는 단순하고 안정적이며 규모 확장이 쉽다.
* 세션 데이터를 저장하는 저장소는 NoSQL을 사용해 규모 확장을 간편하게 할 수 있다.
* 상태 정보가 웹 서버로부터 제거되었으므로 웹 서버의 추가 및 제거가 자유롭다.

## 데이터 센터

* 지리적 라우팅(geoDNS-routing) : 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내된다.
  * geoDNS : 사용자 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스
* 데이터 센터 중 하나에 장애가 발생하면 트래픽은 장애가 없는 데이터 센터로 전송된다.
* 다중 데이터 센터 아키텍처를 만들기 위해 해결해야 할 문제
  * 트래픽 우회
    * 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 한다.
    * GeoDNS는 가장 가까운 데이터 센터로 트래픽을 보낼 수 있도록 해 준다.
  * 데이터 동기화
    * 데이터 센터마다 별도의 데이터베이스를 사용하고 있다면 장애로 인해 다른 데이터 센터로 갔을 때 원하는 데이터가 없을 수 있다.
    * 따라서 보통 데이터를 여러 데이터 센터에 걸쳐 다중화한다.
  * 테스트와 배포
    * 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트해야 한다.
    * 배포는 모든 데이터 센터에 동일한 서비스가 설치되도록 자동화해야 한다.

## 메시지 큐

* 메시지의 무손실을 보장하는 비동기 통신 지원 컴포넌드
* 메시지의 버퍼 역할을 하며 비동기적으로 전송한다.
* 생산자(입력 서비스)가 메시지를 만들어 메시지 큐에 발행하면 소비자(서버, 서비스)가 메시지를 받아 그에 맞는 동작을 수행한다.
* 메시지 큐를 이용하면 서비스 또는 서버 간의 결합이 느슨해져 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.
  * 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있고, 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.

## 로그, 메트릭, 자동화

* 로그
  * 에러 로그를 모니터링
  * 서버 단위로 모니터링할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활요하면 더 펺리하게 검색하고 조회할 수 있다.
* 메트릭
  * 사업 현황에 관한 유용한 정보를 얻을 수도 있고, 시스템의 현재 상태를 손쉽게 파악할 수도 있다.
  * 호스트 단위 메트릭 : CPU, 메모리, 디스크 I/O에 관한 메트릭
  * 종합 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능
  * 핵심 비즈니스 메트릭 : 일별 활동한 사용자, 수익, 재방문 등
* 자동화
  * 생산성을 높이기 위해 자동화 도구를 활용한다.
  * 지속적 통합을 도와주는 도구를 활용하면 개발자가 만드는 코드가 어떤 검증 절차를 자동으로 거치도록 할 수 있어 문제를 쉽게 감지할 수 있다.
  * 빌드, 테스트, 배포 등의 절차를 자동화할 수 있다.

## 데이터베이스의 규모 확장

### 수직적 확장

* 서버에 고성능의 자원을 증설하는 방법
* 수직적 확장의 단점
  * 하드웨어의 한계
  * SPOF로 인한 위험성
  * 고비용

### 수평적 확장

* 데이터베이스의 수평적 확장은 샤딩(sharding)이라고도 부른다.
* 더 많은 서버를 추가해 성능을 향상시킨다.
* 샤딩
  * 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술
  * 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.
* 샤딩 키
  * 파티션 키라고도 부른다.
  * 샤딩 시 데이터를 어떻게 분산할지 결정하는 하나 이상의 칼럼
  * 데이터를 고르게 분할할 수 있도록 하는 게 가장 중요하다.
* 샤딩 시 고려해야 할 문제
  * 데이터의 재 샤딩
    * 데이터가 너무 많아져 하나의 샤드로는 더 이상 감당하기 어려운 경우
    * 샤드 간 데이터 분포가 균등하지 못해 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행되는 경우(샤드 소진)
    * 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치해야 한다.
  * 유명인사(celebrity) 문제
    * 핫스팟 키 문제라고도 불린다.
    * 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
    * 자주 질의가 일어나는 데이터를 여러 샤드에 고르게 분산시켜야 한다.
  * 조인과 비정규화
    * 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면 여러 샤드에 걸친 데이터를 join하기가 힘들어진다.
    * 이는 데이터베이스를 비정규화해 하나의 테이블에서 질의가 수행될 수 있게 함으로써 해결할 수 있다.

## 정리

* 시스템 규모 확장을 위한 기법
  * 웹 계층은 무상태 계층
  * 모든 계층에 다중화 도입
  * 캐시
  * 데이터 센터
  * CDN을 통한 정적 컨텐츠 서비스
  * 샤딩을 통한 데이터 계층 확장
  * 각 계층은 독립적 서비스로 분할
  * 시스템을 지속적으로 모니터링
  * 자동화 도구 활용
