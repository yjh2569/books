# 알림 시스템 설계

## 개략적 설계안 제시 및 동의 구하기

### 알림 유형별 지원 방안

* iOS 푸시 알림
  * 알림 제공자
    * 알림 요청을 만들어 애플 푸시 알림 서비스(APNS : Apple Push Notification Service)로 보내는 주체
    * 알림 요청을 만들기 위한 데이터
      * 단말 토큰(device token) : 알림 요청을 보내는 데 필요한 고유 식별자
      * 페이로드(payload) : 알림 내용을 담은 JSON 딕셔너리
  * APNS : 애플이 제공하는 원격 서비스로 푸시 알림을 iOS로 보낸다.
  * iOS 단말 : 푸시 알림을 수신하는 사용자 단말
* 안드로이드 푸시 알림
  * APNS 대신 FCM(Firebase Cloud Messaging)을 사용한다.
* SMS 메시지
  * 트윌리오, 넥스모 같은 제3사업자의 서비스를 많이 이용한다. 대부분 상용 서비스라 이용요금을 내야 한다.
* 이메일
  * 많은 회사가 상용 이메일 서비스를 이용한다.
  * 센드그리드, 메일침프 등을 사용한다.
  * 전송 성공률도 높고, 데이터 분석 서비스도 제공한다.

### 연락처 정보 수집 절차

* 알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다.
* 사용자가 앱을 설치하거나 처음으로 계정을 등록하면 API 서버는 해당 사용자의 정보를 수집해 데이터베이스에 저장한다.
* user 테이블에 이메일 주소와 전화번호를 저장하고, 단말 토큰은 device 테이블에 저장한다.
  * 한 사용자가 여러 단말을 가지고 있을 수 있기 때문이다.

### 알림 전송 및 수신 절차

* 개략적 설계 초안
  * 1부터 N까지의 서비스
    * 서비스 각각은 마이크로서비스, 크론잡, 분산 시스템 컴포넌트 등이 될 수 있다.
  * 알림 시스템
    * 알림 전송 및 수신 처리의 핵심이다.
    * 서비스에 알림 전송을 위한 API를 제공하고, 제3자 서비스에 전달할 알림 페이로드를 만들어 낸다.
  * 제3자 서비스
    * 사용자에게 알림을 실제로 전달한다.
    * 제3자 서비스와의 통합을 진행할 때 확장성을 유의해야 한다.
    * 즉, 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다.
    * 어떤 서비스는 다른 시장에서 사용할 수 없을 수도 있다.
  * iOS, 안드로이드, SMS, 이메일 단말
* 위 설계의 문제점
  * SPOF : 알림 서비스에 서버가 하나밖에 없는 경우 서버에 장애가 생기면 전체 서비스에 장애가 발생한다.
  * 규모 확장성
    * 한 대의 서비스로 푸시 알림과 관련된 모든 것을 처리하므로 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.
  * 성능 병목
    * 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업이므로 모든 것을 한 서버에서 처리하면 시스템이 과부하 상태에 빠질 수 있다.
* 개선된 개략적 설계
  * 데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리한다.
  * 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어질 수 있도록 한다.
  * 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.
  * 개선안 구조
    * 알림 서버
      * 알림 전송 API : 스팸 방지를 위해 사내 서비스 또는 인증된 클라이언트만 이용 가능하다.
      * 알림 검증 : 이메일 주소, 전화번호 등에 대한 기본적인 검증을 수행한다.
      * 데이터베이스 또는 캐시 질의 : 알림에 포함시킬 데이터를 가져온다.
      * 알림 전송 : 알림 데이터를 메시지 큐에 삽입한다.
    * 캐시 : 사용자 정보, 단말 정보, 알림 템플릿 등을 캐시한다.
    * 데이터베이스 : 사용자, 알림, 설정 등 다양한 정보를 저장한다.
    * 메시지 큐
      * 시스템 컴포넌트 간 의존성을 제거하기 위해 사용한다.
      * 다량의 알림이 전송되기 위한 버퍼 역할도 한다.
      * 알림의 종류별로 별도 메시지 큐를 사용하면 제3자 서비스 중 하나에 장애가 발생해도 다른 종류의 알림은 정상 동작한다.
    * 작업 서버 : 메시지 큐에서 전송할 알림을 꺼내서 제3자 서비스에 전달한다.
    * 제3자 서비스
    * iOS, 안드로이드, SMS, 이메일 단말
  * 알림 전송 과정
    * API를 호출해 알림 서버로 알림을 전송한다.
    * 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 등의 메타데이터를 캐시나 데이터베이스에서 가져온다.
    * 알림 서버는 전송할 알림에 맞는 이벤트를 만들어 적절한 큐에 넣는다.
    * 작업 서버는 메시지 큐에서 알림 이벤트를 꺼내 제3자 서비스에 전달한다.
    * 제3자 서비스는 사용자 단말로 알림을 전송한다.

## 상세 설계

### 안전성

* 데이터 손실 방지
  * 알림 전송 시스템은 어떤 상황에서도 알림이 소실되면 안 된다.
  * 따라서 알림 시스템은 알림 데이터를 데이터베이스에 보관하고 재시도 매커니즘을 구현해야 한다.
  * 알림 로그 데이터베이스를 유지하는 것이 한 가지 방법이다.
* 알림 중복 전송 방지
  * 같은 알림을 여러 번 반복하는 것을 완전히 막는 것은 가능하지 않다.
  * 중복 전송을 줄이려면 중복을 탐지하는 매커니즘을 도입하고, 오류를 신중하게 처리해야 한다.
    * 보내야 할 알림이 도착하면 그 이벤트 ID를 검사해 이전에 본 적이 있는 이벤트면 버리는 방법을 사용할 수 있다.

### 추가로 필요한 컴포넌트 및 고려사항

* 알림 템플릿
  * 알림 메시지 형식은 대부분 비슷하므로, 이를 템플릿으로 저장해두면 메시지의 모든 부분을 처음부터 만들 필요가 없다.
  * 인자나 스타일, 추적 링크를 조정하기만 하면 된다.
  * 전송될 알림의 형식을 일관성 있게 유지할 수 있고, 오류 가능성뿐만 아니라 알림 작성에 드는 시간도 줄일 수 있다.
* 알림 설정
  * 사용자가 알림 설정을 상세히 조정할 수 있도록 한다.
  * 알림 설정 테이블에 해당 정보를 저장하고, 이후 알림을 보낼 때 저장했던 정보를 확인해야 한다.
* 전송률 제한
  * 사용자가 받을 수 있는 알림의 빈도를 제한해 사용자에게 너무 많은 알림이 가지 않도록 한다.
* 재시도 방법
  * 제3자 서비스가 알림 전송에 실패하면 해당 알림을 재시도 전용 큐에 넣는다.
  * 같은 문제가 반복되면 개발자에게 통지한다.
* 푸시 알림과 보안
  * iOS와 안드로이드 앱의 경우 알림 전송 API는 appKey와 appSecret을 사용해 보안을 유지한다.
  * 따라서 인증된, 혹은 승인된 클라이언트만 해당 API를 사용해 알림을 보낼 수 있다.
* 큐 모니터링
  * 큐에 쌓인 알림의 개수에 따라 작업 서버를 증설하거나 줄인다.
* 이벤트 추적
  * 데이터 분석 서비스와의 통합으로 알림 확인율, 클릭율, 실제 앱 사용 비율 등의 이벤트 추적을 수행한다.
* 수정된 설계안
  * 알림 서버에 인증과 전송률 제한 기능 추가
  * 전송 실패 시 재시도 기능 추가(전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도)
  * 전송 템플릿을 사용해 알림 생성 과정 단순화 및 알림 내용의 일관성 유지
  * 모니터링과 추적 시스템을 통한 시스템 상태 확인 및 시스템 개선
