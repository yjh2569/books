# 오브젝트와 의존관계

## 초난감 DAO

### 자바빈

* 자바로 작성된 소프트웨어 컴포넌트
* 다음 두 가지 관례를 따라 만들어진 오브젝트를 의미한다.
  * 디폴트 생성자 : 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문이다.
  * 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 말한다. 프로퍼티는 수정자 메소드(setter)와 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있어야 한다.

### 리플렉션

* 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있게 해주는 자바 API
* 자바는 정적 언어이기 때문에 리플렉션을 사용한다.
* 정적 언어 : 컴파일 시점에 타입을 결정하는 언어
* 프레임워크, 라이브러리에서 주로 사용
* 스프링의 DI, Proxy, ModelMapper 등이 있다.
* Examples
  * getDeclaredFields() : Class의 모든 필드를 가져온다.
  * getType(), getName() : Class 내 Field의 타입 및 이름을 가져온다.

## DAO의 분리

### 리팩토링

* 기존의 코드를 외부의 동작방식 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
* 코드 내부 설계를 개선해 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다.

### 디자인 패턴

* 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
* 주로 객체지향 설계에 관한 것이다.
* 객체지향적인 설계로부터 문제를 해결하기 위한 확장성 추구 방법은 크게 클래스 상속과 오브젝트 합성으로 나뉜다.

### 템플릿 메소드 패턴

* 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 필요에 맞게 구현해서 사용하는 방법
* 스프링에서 애용되는 디자인 패턴이다.
* 훅 메소드 : 슈퍼클래스에서 디폴트 기능을 정의하거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드

### 팩토리 메소드 패턴

* 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것
* 슈퍼클래스 코드에서는 서브클래스에서 구현한 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다.
* 메소드는 주로 인터페이스 타입으로 오브젝트를 반환하기에 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다.
* 팩토리 메소드 : 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드
* 자바에서는 오브젝트를 생성하는 기능을 가진 메소드를 팩토리 메소드라고 부르기도 하는데, 위에서 나온 팩토리 메소드와 의미가 다르다.

### 상속의 한계

* 자바에서는 다중상속을 허용하지 않는다.
* 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있고, 이로 인해 슈퍼클래스 내부의 변경이 있을 때마다 모든 서브클래스를 수정하거나 다시 개발해야 한다.

## DAO의 확장

### 개방 폐쇄 원칙

* 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되어 있고, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 폐쇄되어 있다.

### 높은 응집도

* 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 의미
* 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않다.
* 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다.

### 낮은 결합도

* 책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것
* 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다.
* 결합도 : 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도

### 전략 패턴

* 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
* 여기서 말하는 알고리즘은 독립적인 책임으로 분리가 가능한 기능을 말한다.
* 전략 패턴을 사용하는 클라이언트는 컨텍스트가 사용할 전략을 컨텍스트의 생성자 등을 통해 제공해주는 게 일반적이다.

## 제어의 역전

### 팩토리

* 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 반환하는 오브젝트
* 오브젝트를 생성하는 쪽과 오브젝트를 사용하는 쪽의 역할과 책임을 분리하기 위해 사용한다.
* 컴포넌트의 구조와 관계를 정의한 설계도 역할을 한다.

### 제어의 역전

* 오브젝트의 제어 권한을 자신이 아닌 다른 대상에게 위임하는 것
* 서블릿의 경우 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다.
* 템플릿 메소드 패턴의 경우 서브클래스에서 구현한 메소드의 제어권을 상위 템플릿 메소드에 넘기고 필요할 때 호출되어 사용한다.
* 프레임워크는 제어의 역전의 대표적인 예시다.
* 프레임워크뿐만 아니라 폭넓게 사용되는 프로그래밍 모델이다.
* 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.

### 라이브러리와 프레임워크

* 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.
* 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다.
* 프레임워크 위에 개발한 클래스를 등록하고, 프레임워크가 흐름을 주도하면서 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식
* 프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 한다.

## 스프링의 IoC

### 빈

* 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
* 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트

### 애플리케이션 컨텍스트

* 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트(빈 팩토리)의 일종
* 빈의 생성 및 관계설정 뿐만 아니라 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당한다.
* 애플리케이션 로직을 담당하지 않고 IoC 방식을 이용해 애플리케이션 컴포넌트를 생성하고, 사용할 관계를 맺어주는 등의 책임을 담당한다.
* 오브젝트의 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻는다.
* 때로는 외부의 오브젝트 팩토리에 그 작업을 위임하고 그 결과를 가져다가 사용하기도 한다.

### 스프링 애노테이션

* @Configuration : 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스
* @Bean : 오브젝트를 만들어주는 메소드

### 애플리케이션 컨텍스트 사용

* 애플리케이션 컨텍스트는 ApplicationContext 타입의 오브젝트
* ApplicationContext를 구현한 클래스는 여러 가지가 있는데, @Configuration이 붙은 자바 코드를 설정정보로 사용하려면 AnnotationConfigApplicationContext를 이용하면 된다. 생성자 파라미터로 @Configuration이 붙은 클래스를 넣어준다.
* getBean()이라는 메소드를 이용해 오브젝트를 가져올 수 있다. 파라미터로는 빈의 이름과 빈의 클래스 타입을 받는다.
* @Bean 애노테이션을 붙인 메소드의 이름이 빈의 이름이다.

### 애플리케이션 컨텍스트의 동작 방식

* 애플리케이션 컨텍스트는 설정정보로 등록한 클래스에서 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어 둔다.
* 클라이언트가 getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

### 애플리케이션 컨텍스트의 장점

* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
  * 기존의 방식에서는 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야 할지 알아야 하고, 필요할 때마다 팩토리 오브젝트를 생성해야 한다.
  * 애플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 많아져도 이를 알아야 하거나 직접 사용할 필요가 없다.
  * 자바 코드가 아닌 XML처럼 단순한 방법을 사용해 IoC 설정정보를 만들 수도 있다.
* 종합 IoC 서비스를 제공해준다.
  * 오브젝트 생성과 다른 오브젝트와의 관계설정만 해주지 않는다.
  * 오브젝트 생성 방식, 시점 및 전략을 다르게 할 수도 있다.
  * 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.
  * 또한 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도 한다.
* 빈을 검색하는 다양한 방법을 제공한다.
  * 빈의 이름, 타입, 특별한 애노테이션을 통해 빈을 검색할 수 있다.

### 용어 정리

* 빈 : 스프링이 직접 그 생성과 제어를 담당하는 오브젝트
* 빈 팩토리 : 스프링의 IoC를 담당하는 핵심 컨테이너
* 애플리케이션 컨텍스트 : 빈 팩토리를 확장해 스프링이 제공하는 각종 부가 서비스를 제공하는 IoC 컨테이너
* 설정정보 : 애플리케이션 컨텍스트(빈 팩토리)가 IoC를 적용하기 위해 사용하는 메타정보
* 컨테이너 : 애플리케이션 컨텍스트를 스프링 컨테이너라고도 한다.
* 스프링 프레임워크 : IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 사용한다.  

## 싱글톤 레지스트리와 오브젝트 스코프

### 서버 애플리케이션과 싱글톤

* 스프링은 서버환경에서 사용되기 때문에 싱글톤으로 빈을 만든다.
* 싱글톤 패턴 : 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용한다.

### 싱글톤 패턴의 한계

* private 생성자를 갖고 있기 때문에 상속할 수 없다.
  * 상속 및 다형성을 적용할 수 없다.
* 테스트하기 어렵다.
  * 만들어지는 방식이 제한적이기 때문에 목 오브젝트 등으로 대체하기 어렵다.
* 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  * 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.
* 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
  * 싱글톤의 스태틱 메소드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있어 애플리케이션 어디서든지 사용될 수 있고, 이로 인해 전역 상태로 사용되기 쉽다.

### 싱글톤 레지스트리

* 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는 싱글톤 레지스트리다.
* 스프링 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다.
* 싱글톤 레지스트리는 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.
* 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있고, 따라서 오브젝트를 직접 생성해서 사용할 수 있고, 테스트 환경에서도 오브젝트를 만들거나 목 오브젝트로 대체할 수 있다.
* 생성자 파라미터를 이용해 사용할 오브젝트를 넣어주게 할 수도 있다.

### 싱글톤과 오브젝트의 상태

* 싱글톤은 멀티스레드 환경인 경우 상태 관리에 주의해야 한다.
* 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우 무상태 방식으로 만들어져야 한다.
* 무상태 방식에서 각 요청에 대한 정보, DB나 서버의 리소스로부터 생성한 정보는 인스턴스 변수에 저장하면 안 되고, 파라미터와 로컬 변수, 리턴 값 등을 이용한다.
* 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 좋다. 스프링이 한 번 초기화해주고 나면 이후에는 수정되지 않기 때문이다.
* 읽기전용의 속성을 가진 정보도 싱글톤에서 인스턴스 변수로 사용해도 좋다.

### 스프링 빈의 스코프

* 스코프 : 빈이 생성되고, 존재하고, 적용되는 범위
* 스프링 빈의 기본 스코프는 싱글톤으로, 컨테이너 내에 한 개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
* 프로토타입 스코프 : 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.
* 요청 스코프 : HTTP 요청이 생길 때마다 생성된다.
* 세션 스코프 : 웹의 세션과 스코프가 유사하다.

## 의존관계 주입

### 의존관계

* A가 B에 의존하고 있다는 것은 B가 변하면 A에 영향을 미친다는 의미이다.
* 의존관계에는 방향성이 있다.
* 인터페이스에 대해서만 의존관계를 만들어주면 인터페이스 구현 클래스와의 관계가 느슨해져 결합도가 낮아진다.
* 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 다르다.
* 의존 오브젝트 : 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트
* 의존관계 주입 : 의존 오브젝트와 클라이언트 오브젝트를 런타임 시에 연결해주는 작업

### 의존관계 주입

* 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다.
* 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
* 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.
* 외부에서 파라미터로 오브젝트를 넘겨줬다고 해서 다 DI가 아니다.
  * 주입받는 메소드 파라미터가 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다.
  * DI에서 말하는 주입은 인터페이스 타입의 파라미터를 통해 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있어야 한다.

### 의존관계 검색

* 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 단, 자신이 어떤 클래스의 오브젝트를 이용할지 결정하지는 않는다.
* 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡긴다.
* 오브젝트를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
* 스프링의 애플리케이션 컨텍스트는 getBean() 메소드를 의존관계 검색에 사용한다.
* 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타나기에 바람직하지는 않다.
* 애플리케이션 기동 시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다.
* 의존관계 검색은 검색하는 오브젝트가 스프링의 빈일 필요가 없지만, 의존관계 주입은 클라이언트 오브젝트가 반드시 스프링의 빈이어야 한다.

### 메소드를 이용한 의존관계 주입

* 수정자 메소드를 이용한 주입
  * 수정자 메소드를 통해 파라미터로 전달된 값을 내부의 인스턴스 변수에 저장할 뿐만 아니라, 입력 값에 대한 검증 등의 작업을 수행할 수도 있다.
* 일반 메소드를 이용한 주입
  * 수정자 메소드와는 달리 한 번에 여러 개의 파라미터를 받을 수 있다.
  * 적절한 개수의 파라미터를 가진 여러 개의 초기화 메소드를 만들 수 있다.
* 자바 코드 대신 XML을 사용하는 경우 수정자 메소드가 가장 사용하기 편리하다.

## XML을 이용한 설정

### XML을 통한 설정의 장점

* 단순한 텍스트 파일이기 때문에 다루기 쉽다.
* 컴파일과 같은 별도의 빌드 작업이 없다.
* 환경이 달라져서 오브젝트의 관계가 바뀌는 경우에도 빠르게 변경사항을 반영할 수 있다.
* 스키마나 DTD를 이용해서 정해진 포맷을 따라 작성됐는지 쉽게 확인할 수 있다.

### XML 설정 방식

* DI 정보가 담긴 XML 파일은 \<beans\>을 루트 엘리먼트로 사용한다.
* \<beans\> 안에는 여러 개의 \<bean\>을 정의할 수 있다.
* \<beans\>는 @Configuration, \<bean\>은 @Bean에 대응된다.
* \<bean\>에 빈의 이름, 클래스, 의존 오브젝트 정보를 정의한다. 의존 오브젝트가 없는 경우 생략한다.
* 빈의 이름은 id 애트리뷰트를 이용해 정의한다.
* 빈의 클래스는 class 애트리뷰트를 이용해 정의한다. 단, 메소드의 리턴 타입이 아닌, 메소드에서 오브젝트를 만들 때 사용하는 클래스 이름을 사용한다.
* 클래스 이름은 패키지까지 모두 포함해야 한다.
* 의존 오브젝트와의 관계는 \<property\> 태그를 사용한다.
* \<property\> 태그는 name과 ref라는 두 개의 애트리뷰트를 가진다.
* name은 프로퍼티의 이름으로, 수정자 메소드 이름에서 set을 제외한 나머지 부분을 의미한다.
* ref는 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름이다.
* 보통 name과 ref가 인터페이스 이름으로 같은 경우가 대부분이나, 다르게 정해도 상관없다.
* 때로는 같은 인터페이스를 구현한 의존 오브젝트를 여러 개 정의해두고 그 중에서 원하는 걸 골라서 DI하는 경우도 있다.

### XML을 이용하는 애플리케이션 컨텍스트

* XML에서 빈의 의존관계 정보를 이용하는 IoC/DI 작업에는 GenericXmlApplicationContext를 사용한다.
* GenericXmlApplicationContext의 생성자 파라미터로 XML 파일의 클래스패스를 지정해준다.
* 애플리케이션 컨텍스트가 사용하는 XML 설정파일의 이름은 관례를 따라 applicationContext.xml이라고 만든다.
* 생성자에 applicationContext.xml의 클래스패스를 넣을 때 클래스패스를 시작하는 /를 넣을 수도 있고 생략할 수도 있다. 시작하는 /가 없는 경우에도 항상 루트에서부터 시작하는 클래스패스다.
* ClassPathXmlApplicationContext를 이용하면 XML 파일과 같은 클래스패스에 있는 클래스 오브젝트를 넘겨서 클래스패스에 대한 힌트를 제공할 수 있다.

### DataSource 인터페이스

* 자바에서는 DB 커넥션을 가져오는 오브젝트의 기능을 추상화해서 사용할 수 있게 만들어진 DataSource라는 인터페이스가 존재한다.
* 다양한 방법으로 DB 연결과 풀링 기능을 갖춘 많은 DataSource 구현 클래스가 존재해 이를 가져다 사용하면 된다.
* DataSource 인터페이스에서 실제로 관심을 가질 것은 getConnection() 메소드 하나뿐이다.

### 프로퍼티 값의 주입

* dataSoucre의 XML 설정 시, dataSource 빈을 등록할 때 dataSource 구현 클래스의 수정자로 DB 접속정보를 넣어줘야 하나, 이는 다른 빈에 의존하는 것이 아닌 단순 Class 타입의 오브젝트나 텍스트 값이다.
* 텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것을 값을 주입한다고 말한다. 일종의 DI라고 볼 수 있다.
* \<property\>를 사용해 정보를 주입하는 것은 동일하나, ref 애트리뷰트가 아닌 value 애트리뷰트를 사용한다.
* 스프링은 프로퍼티의 값을, 수정자 메소드의 파라미터 타입을 참고로 해서 적절한 형태로 변환해준다.
  * 따라서 value에 지정한 텍스트 값을 적절한 자바 타입으로 변환해준다.
