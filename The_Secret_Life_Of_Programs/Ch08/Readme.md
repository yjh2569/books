# 프로그래밍 언어 처리

## 어셈블리 언어

* 기계어로 프로그램을 구현하려면 각 명령어에 대응하는 비트 조합을 알아야 한다. 따라서 프로그래머가 좀더 쉽게 프로그램을 만들도록 구현한 언어가 어셈블리 언어다.
* 니모닉(mnemonics)을 통해 명령어를 쓰고, 레이블(label)을 통해 주소에 이름을 붙인다.
* 코드에 주석도 달 수 있어 다른 사람들이 프로그램을 더 쉽게 읽고 이해하도록 도와준다.
* 어셈블러(assembler) : 어셈블리 언어로 작성된 코드를 기계어 코드로 변환해주는 프로그램. 이 과정에서 레이블이나 심볼의 값을 결정해 채워 넣는다.

## 고수준 언어

* 어셈블리 언어보다 더 높은 추상화 단계에서 작동한다.
* 고수준 언어의 소스 코드는 컴파일러라는 프로그램에 의해 실행된다.
* 컴파일러(compiler) : 소스 코드를 기계어 코드(목적 코드)로 변역(컴파일)해준다. 

## 구조적 프로그래밍

* 초기에 발명된 고수준 언어인 포트란이나 베이직은 비구조적 언어로 프로그램이 복잡해짐에 따라 줄 번호와 GOTO로 이뤄진 연결을 관리하기가 힘들어졌다. 따라서 잘못된 GOTO 사용으로 인해 발생할 수 있는 스파게티 코드 문제를 해결하기 위해 개발되었다.
* 현재 많이 쓰이는 C, C++, 자바, PHP, 파이썬 등이 있다.

## 어휘 분석

* 코드를 기호(문자들)로부터 단어와 같은 성격인 토큰(token)으로 변환하는 과정
* 토큰을 추출하는 것뿐만 아니라 이름, 숫자, 연산자 등 토큰 유형도 많아 토큰을 잘 구분해야 한다.
> 수를 표현하는 상수도 제대로 구분하기 위해서는 부호, 부동소수점, 지수 등 여러 요소를 고려해야 한다.
* 배커스-나우르 표기법(BNF) : 언어를 정의하는 형식적인 방법

### 상태 기계

* 상태로 이뤄진 집합과 한 상태에서 다른 상태로 전이되는 원인의 목록으로 이루어진다.
* 상태 기계를 사용하면 간단한 코드를 통해 입력을 쉽게 분류할 수 있다.

### 정규식

* 패턴 매칭에서 중추적 역할을 한다.
* 몇 가지 간단한 규칙을 통해 입력을 토큰으로 처리할 수 있다.
* lex : 입력이 정규식과 매치될 때 사용자가 제공한 프로그램 조각을 실행해주는 상태 테이블 기반의 프로그램을 생성해준다.
* lex를 활용해 발견한 토큰의 유형을 정의된 값으로 반환하도록 프로그램을 만들 수 있다.

## 단어에서 문장으로

* yacc : 토큰으로 이뤄진 시퀀스에 대한 패턴 매칭을 위해 상태 테이블을 만들고 이를 사용해 작동하는 코드를 생성해주는 프로그램
* 시프트-리듀스 파서 : yacc이 만들어내는 프로그램으로 스택을 사용한다. 토큰을 스택에 넣고(시프트), 스택의 맨 위부터 매치된 토큰들을 다른 어떤 것으로 대치한다(리듀스).

## 파스 트리

* 인터프리트(interpret) : 실제 기계에서 실행할 수 있는 프로그램을 만들어내는 컴파일러와 달리 가상 머신에서 실행할 인터프리터 언어를 만드는 과정
  * 가상 머신은 소프트웨어로 작성된 기계로 자신만 실행할 수 있는 기계어를 제공하기도 하지만, 실제 하드웨어로 구현된 컴퓨터 명령어 집합은 아니다.
  * 일부 인터프리터 언어는 인터프리터에 의해 직접 실행되기도 하고, 나중에 해석될 수 있도록 중간어(intermediate language)로 컴파일되기도 한다.
  * 컴파일이 된 코드는 기계어이기 때문에 인터프리터에 의해 실행되는 코드보다 더 빠르게 실행된다.
  * 인터프리터로 실행되는 코드는 하드웨어로 구현하기에 어려운 기능을 제공할 수 있다.
* 파스 트리(parse tree) : 언어 문법으로부터 만들어낸 DAG(directed acyclic graph) 데이터 구조
  * 트리 내 각 노드에는 노드 유형을 표시하는 code와 leaf들의 배열이 있다.
  * 각 leaf의 해석은 code에 따라 달라지고, leaf는 여러 타입의 정보를 담을 수 있어야 하기 때문에 공용체다.

## 인터프리터

* 파스 트리를 구성한 뒤 파스 트리의 루트를 인자로 받는 함수를 호출해 파스 트리를 실행한다.
* 파스 트리의 연결 리스트를 순회(깊이 우선 순회가 이루어진다)하면서 계산한다.
* 변수와 변수의 값을 심볼 테이블에 저장하는 함수와 변수에 연관된 값을 검색하는 함수가 추가로 필요하다. 이런 함수는 보통 해시 테이블을 사용한다.
* 파스 트리를 즉시 실행하거나 파스 트리를 파일에 저장했다가 나중에 읽어서 실행한다.
* 인터프리터는 크게 프론트엔드와 백엔드로 나눌 수 있다. 프론트엔드는 어휘 분석 및 문법 파싱을 통해 파스 트리(중간 언어)를 만들고, 백엔드는 이 언어를 실행할 대상 환경마다 하나씩 존재한다.

## 컴파일러

* 프론트엔드는 인터프리터와 같으나 백엔드 실행 코드 대신 코드 생성기가 들어가 특정 대상 기계에 대한 기계어 코드를 만든다.
* 일부 언어의 코드 생성기는 대상 기계의 어셈블리 언어 코드를 만들고, 이는 대상 기계의 어셈블러를 통해 대상 기계의 기계어로 번역된다.
* 컴파일된 기계어로 실행하면 코드가 더 작고 효율적이기 때문에 인터프리터로 실행할 때보다 훨씬 더 빠르게 실행된다.

## 최적화

* 최적화기(optimizer) : 파스 트리와 코드 생성기 사이에 들어가 파스 트리를 분석하고 이 결과를 활용해 더 효율적인 코드를 생성해내도록 파스 트리를 변환한다.
* 컴파일 시점에 식을 미리 계산하거나, 루프 불변 요소를 루프 밖으로 빼내거나, 강도 절감을 통해 비용이 많이 드는 연산을 비용이 더 적게 드는 연산으로 대신하는 등 여러 가지 방법으로 최적화를 수행한다.
* 하드웨어를 조작하는 코드의 경우 최적화 시 예기치 못한 문제가 발생할 수 있으므로 경우에 따라 최적화를 꺼야 할 수도 있다.