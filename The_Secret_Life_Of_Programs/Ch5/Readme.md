# 컴퓨터 아키텍처와 운영체제

* 컴퓨터 아키텍처 : 컴퓨터의 여러 구성요소를 배치하는 방법
* 여러 프로그램을 동시에 실행하는 멀티태스킹을 위해서는 프로그램들의 실행을 제어하기 위한 운영체제가 필요하다.

## 기본적인 구조 요소들

* 컴퓨터는 기본적으로 CPU와 I/O 장치, 메모리로 구성되어 있다.
* 폰 노이만 구조 : 하나의 메모리만 존재하며 데이터 버스와 주소 버스가 하나 뿐이다.
* 하버드 구조 : 메모리가 명령어 메모리와 데이터 메모리로 나누어져 있어 데이터 버스와 주소 뱌스가 두 개 필요하다.

### 프로세스 코어

* 멀티프로세서를 잘 활용하려면 프로그램의 병렬화 문제를 해결해야 한다.
* 반도체 회로 크기가 줄어듦과 동시에 기계가 빨라지면서 전력을 더 많이 소모하게 되어 단위 면적당 발생하는 열이 많아지면서 전력 장벽에 부딪혔다. 
* 전력 장벽 : 열로 인해 회로를 이루는 물질의 녹는점 이상으로 온도가 올라갈 수 있어 전력 소모에 한계가 발생하는 현상
* 과거에 CPU라 부르던 것을 현재는 프로세스 코어라 부르고, 이런 코어가 여럿 들어가는 멀티코어 프로세서가 일반적으로 쓰인다.

### 마이크로프로세서와 마이크로컴퓨터

* 마이크로프로세서 : 메모리와 I/O가 프로세스 코어와 같은 패키지에 들어있지 않은 프로세스
* 마이크로컴퓨터 : 모든 요소를 한 칩 안에 패키징한 프로세스
* 마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로컴퓨터는 식기세척기 등 간단한 전자기기에서 찾을 수 있는 컴퓨터다.
* 단일 칩 시스템(SoC, System on a Chip) : 더 복잡한 마이크로컴퓨터로, 간단한 온칩 I/O를 제공하는 대신 WiFi 회로 등의 더 복잡한 장치가 들어 있다. 핸드폰 등의 장치에서 볼 수 있다.

## 함수

* 함수(function, orocedure, subroutine) : 코드를 재사용하는 주요 수단
* 함수를 실행할 때 함수에서 원래 자리로 돌아오기 위해 반환 주소를 따로 저장해 두어야 한다. 
* 함수 실행이 끝난 뒤 원래 자리로 돌아올 때 반환 주소를 통한 간접 분기를 이용한다.

## 스택

* LIFO 구조로 물건을 푸시(push)해 넣고 팝(pop)해서 제거한다. 마지막으로 넣은 물건을 가장 먼저 꺼낸다.
* 스택 오버플로(stack overflow) : 스택에 물건을 푸시하는데 더 이상 들어갈 공간이 없는 경우
* 스택 언더플로(stack underflow) : 빈 스택에서 물건을 가져오려고 하는 경우
* 컴퓨터 하드웨어는 함수 호출 시 반환 주소를 저장하기 위해 스택을 사용한다.
* 스택에는 함수에서 사용하는 지역 변수 역시 저장할 수 있다.
* 스택 프레임 : 함수가 호출될 때마다 스택에 저장되는 데이터의 집합

## 인터럽트

* 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함한다.
* 핀 : 칩에 연결된 전기적 접점
* 많은 프로세서 칩에는 통합 주변장치(integrated peripheral)가 들어 있고, 이런 장치들은 내부적으로 인터럽트 시스템에 연결되어 있다.
* 인터럽트 과정
  1. 주변장치가 인터럽트 요청을 생성한다.
  2. 프로세서는 현재 실행 중인 명령어를 끝까지 실행한 뒤 프로그램을 잠시 중단시키고 인터럽트 핸들러(함수)를 실행하기 시작한다.
  3. 인터럽트 핸들러가 필요한 작업을 마치면 원래 실행 중인 프로그램을 중단된 위치부터 다시 실행한다.
* 인터럽트 처리를 위해서는 응답 시간과 상태 저장 방법에 대해 고려해야 한다. 인터럽트 처리가 너무 오래 걸려서는 안 될 것이고, 인터럽트가 끝난 뒤 원래 프로그램을 정상적으로 수행하기 위해 필요한 여러 상태들(예: 레지스터에 저장된 값들)이 복원되어야 한다.
* 인터럽트 벡터 : CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 지정한다.
* 마스크 : 인터럽트를 중단시킬 수 있는 장치
* 인터럽트가 많은 기계에서는 인터럽트 간의 우선순위가 존재한다.

## 상대 주소 지정

* 절대 주소 지정 : 명령어 주소가 특정 메모리 주소를 직접적으로 가리킨다.
* 인덱스 레지스터 : 절대 주소를 사용하는 프로그램이 다른 위치에 올라와 실행이 어려워지는 것을 해결하기 위해 추가한 레지스터. 인덱스 레지스터의 값을 명령어에 들어 있는 주소와 더해서 유효 주소를 계산한다.
* 상대 주소 지정 : 명령어에 들어 있는 주소를 0부터 시작하는 위치로 해석하지 않고, 명령어의 주소를 기준으로 하는 상대적인 주소로 해석한다. 상대 주소 지정을 사용하면 프로그램을 메모리의 원하는 위치로 재배치할 수 있다.

## 메모리 관리 장치(MMU)

* 가상 주소와 물리 주소를 구분한다. 프로그램은 가상 주소를 사용해 작성되고, MMU가 가상 주소를 물리 주소로 변환해 준다.
* 가상 메모리 주소를 두 부분으로 나눠 주소의 하위 부분은 물리적 주소 범위로, 상위 부분은 페이지 테이블을 통해 주소를 변환한다.
* 메모리를 같은 크기의 페이지로 분할해 메모리 내 여러 위치에 저장하고, 페이지 테이블에는 각 페이지의 물리 메모리 상에서 실제 위치를 저장한다.
* 페이지 테이블 항목은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장된다.
* 일부 MMU 설계는 페이지 테이블에 제어 비트를 추가로 제공하기도 한다. 제어 비트의 예시로는 실행 불가 비트(설정 시 해당 페이지에 있는 명령어 실행 불가능), 읽기 전용 비트 등이 있다.
* 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트 예외가 발생한다.

## 가상 메모리

* OS는 MMU를 통해 사용자 프로그램에게 가상 메모리를 제공해 프로그램이 필요한 만큼 많은 메모리를 제공할 수 있다.
* 요청받은 메모리가 사용 가능한 메모리 크기보다 큰 경우 스왑 아웃, 스왑 인을 통해 메모리 페이지를 디스크로부터 가져오거나 디스크로 옮긴다.
* 이런 식으로 페이지를 처리하는 것을 demand paging이라 한다.

## 시스템 공간과 사용자 공간

* CPU에는 컴퓨터가 시스템 모드에 있는지 사용자 모드에 잇는지 결정하는 비트가 어떤 레지스터 안에 들어 있다.
* I/O를 처리하는 명령어 등 일부 명령어는 특권 명령어라서 시스템 모드에서만 실행할 수 있기에, 사용자 모드에서 실행 중인 프로그램이 이를 실행하고 싶으면 트랩이나 시스템 콜을 통해 운영체제에게 요청을 보내야 한다.
* 이를 통해 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호할 수 있다. 그리고 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다.

## 메모리 계층과 성능

* CPU와 메모리, 디스크 간에는 속도의 차이가 발생하기에 명령어를 효율적으로 실행하려면 이를 최대한 줄이는 것이 중요하다.
* CPU에 캐시를 추가해 메모리에서 데이터를 가져올 때 지역성을 고려하여 앞으로 사용할 가능성이 높은 데이터를 같이 가져온다. 
> CPU 메모리 컨트롤러는 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져와 캐시 적중률을 높인다.
* 캐시 적중(cache hit) : CPU가 원하는 내용을 캐시에서 찾은 경우 ↔ 캐시 실패(cache miss)
* 캐시 메모리에도 L1, L2, L3 캐시로 몇 가지 계층이 있다.

## 코프로세서

* 프로세서 코어의 일부 연산을 위임받아 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보할 수 있도록 돕는 프로세서
* 직접 메모리 접근(DMA) : 메모리와 디스크 사이의 데이터 복사만 담당하는 코프로세서

## 메모리 상의 데이터 배치

* 정적(static) 데이터 : 프로그램 작성 시 얼마나 많은 메모리가 필요한지 알고 있는 데이터
* 동적(dynamic) 데이터 : 프로그램 실행 전까지는 크기를 알 수 없는 데이터. 스택과 힙이 있다.
  * 힙(heap) : 정적 데이터가 차지하는 영역 바로 위 영역에 쌓이는 데이터
  * 스택은 아래로 자라나는 반면, 힙은 위로 자라난다.

## 프로그램 실행

* 라이브러리 : 자주 사용하는 함수들의 집합
* 연결(link) : 여러 조각으로 나눠진 프로그램을 하나로 엮는 것
* 각 프로그램을 링크하기 편한 형식의 매개 파일로 나누고, 링커라는 특별한 프로그램을 사용해 여러 조각을 하나로 연결해 실행한다.
* 정적 링크(static linking) : 라이브러리를 필요한 함수가 들어 있는 파일로 간주하고 프로그램의 나머지 부분과 직접 연결해 실행 파일을 만드는 연결 방식
* 동적 링크(dynamic linking) : 공유 라이브러리를 사용해 여러 프로그램이 같은 라이브러리를 공유할 수 있게 하는 연결 방식
* 진입점(entry point) : 프로그램의 첫 번째 명령어가 위치한 주소
* 실제 프로그램이 실행될 때는 진입점에 있는 명령어가 가장 먼저 실행되지 않는다. 실제로는 프로그램을 이루는 모든 부분이 하나로 합쳐져 실행파일을 만들 때 런타임 라이브러리가 추가되어 이 런타임 라이브러리에 있는 명령어가 먼저 실행된다.
* 런타임 라이브러리는 스택과 힙 영역을 설정하고, 정적 데이터에 위치한 데이터의 초깃값을 설정한다. 이런 값들은 실행 파일에서 들어있어 시스템에서 메모리를 할당받은 직후 메모리로 복사돼야 한다.