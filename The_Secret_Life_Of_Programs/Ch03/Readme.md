# 메모리와 디스크의 핵심: 순차논리

## 시간 표현과 상태 기억

### 발진자

* 피드백(feedback) : 인버터의 출력을 입력에 연결하는 방식. 이로 인해 출력이 0과 1 사이를 진동하고, 진동 속도는 전파 지연에 따라 결정된다. 따라서 온도에 따라 달라지기에 불안정하다.
* 크리스털 발진자 : 크리스털의 압전 효과를 활용하여, 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어내는 발진자로 매우 정확하다.

### 클록

* 시간을 셀 수 있게 해주는 신호로 발진자가 컴퓨터에 제공한다.
* 회로의 페이스(pace)를 결정한다.
* 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다.

### 래치

* OR 게이트 래치(latch)
  * OR 게이트의 출력을 입력에 묶는 방식의 피드백을 이용해 정보를 기억할 수 있다. 
  * 가장 기본적인 저장 회로이지만 한 번 출력을 1로 만들면 다시 0으로 바꿀 수 없다.

![OR_gate_latch](https://user-images.githubusercontent.com/70595250/147093452-4ce3a884-e669-46cb-93c6-a254c56a05d5.PNG)
* AND-OR 게이트 래치
  * OR 게이트 래치에 재설정(reset) 기능을 추가한 래치이다.
  * 액티브 하이 : 1일 때 참이고 0일 때 거짓
  * 액티브 로우 : 0일 때 참이고 1일 때 거짓
  * 입력으로 set과 reset을 받는데, set은 원래 입력 값, reset은 set이 1인 경우 0으로 바꿀지를 나타내는 비트로 보통 set의 not 함수를 적용한 결과이다.
  * reset의 경우 인버터를 적용해 반전시키는데(이를 reset bar라고 부른다.), 이로 인해 액티브 로우가 된다. 
  * reset이 로우이면 reset bar가 하이(거짓)이므로 OR 게이트의 출력은 OR 게이터의 입력에 피드백된다. 즉, 원래 저장된 값을 계속 유지한다.
  * reset이 하이이면 reset bar가 로우(참)이므로 피드백이 깨지고 출력이 0이 된다.

![AND_OR_gate_latch](https://user-images.githubusercontent.com/70595250/147093579-91a6d960-2ccf-4efa-9616-e0140d5352fa.PNG)
* S-R 래치
  * set-reset을 뜻하며, 액티브 로우 입력을 받고 보수 출력(Q, Q')을 제공한다.
  * 보수 출력 : 출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우
  * NAND 게이트를 대칭으로 배치하여 set과 reset 신호의 지연 시간이 거의 비슷하다.
  * set과 reset이 모두 참인 경우 보수 출력이 모두 참이 나와 이런 입력은 사용하지 않는다.
  * set과 reset이 모두 거짓인 경우 전파 지연 시간에 따라 출력이 달라져 결과를 예측할 수 없다.

![S-R_latch](https://user-images.githubusercontent.com/70595250/147094246-01703e56-1084-4667-8efd-96c1249ce55d.PNG)

### 게이트가 있는 래치

* gate를 추가하면 게이트가 참인 경우(열린 경우)에만 출력을 수정할 수 있다.
* gate가 참인 상태에서는 D(입력)의 변화가 그대로 출력에 나타나기 때문에, gate를 여는 시간을 최소화해 D가 그 사이에 상태가 변경되지 않기를 바라는 수밖에 없다.

### 플립플롭

* 에지(edge) : 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것
* 여기서 에지는 시간에 대한 판정 기준이라 생각할 수 있다.
* 플립플롭(flip-flop) : 에지에 의해 데이터 변화가 촉발되는 래치
* 3개의 S-R 래치를 잘 연결하면 양의 에지에 의해 변화가 촉발되는 플립플롭(D 플립플롭)을 만들 수 있다. 이는 논리 수준이 0에서 1로 바뀌는 순간에 플립플롭의 출력을 바꾼다.
* 에지에 의해 상태 변화가 촉발되는 장치의 상태 변화 타이밍을 볼 때는 전파 지연 외의 요소도 고려해야 한다. 이를 위해 설정 시간과 유지 시간이 필요하다.
* 설정 시간(setup time) : 클록 에지가 발생하기 전에 얼마나 오랫동안 신호가 안정적으로 유지돼야 하는지를 나타낸다.
* 유지 시간(hold time) : 클록 에지가 발생한 이후에 얼마나 오랫동안 입력 신호가 안정적으로 유지돼야 하는지를 나타낸다.
* 이를 활용해 카운터, 레지스터 등을 만든다.

### 레지스터

* 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것
* 가산기 출력을 클록을 사용해 레지스터에 넣고 나면, 플립플롭의 원리에 의해 가산기의 입력을 바꿔도 결과는 바뀌지 않는다.

## 메모리 조직과 주소 지정

* 여러 개의 레지스터를 사용하는 경우 어떤 레지스터를 사용해야 하는지를 지정하기 위해 각 레지스터에 부여하는 번호인 주소라는 개념이 도입되었다.
* 주소를 입력받은 디코더는 해당 주소에 대응하는 레지스터를 찾는다.
* 지정한 주소에 해당하는 레지스터의 출력을 선택할 때 실렉터를 사용한다.
* 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있는데, 이런 경우 트라이스테이트 출력이라는 또 다른 기본 요소가 필요하다.
* 버스(bus) : 여러 비트를 한 번에 이동시키는 신호로 주소 버스와 데이터 버스가 있다.
* 메모리 칩은 내부에서 격자로 관리되고, 주소를 행과 열로 나눠 메모리 내부 위치를 지정한다.
* 행과 열 주소를 멀티플렉싱하면 주소 라인의 수를 반으로 줄일 수 있다.

### 임의 접근 메모리(RAM)

* 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다.
* SRAM(static RAM) : 비싸지만 아주 빠르다. 각 비트에 트랜지스터가 6개 들어가기에 많은 양의 비트를 저장하는 것이 어렵다.
* DRAM(dynamic RAM)
  * 커패시터(capacitor)라는 아주 작은 버킷에 전자를 담고 트랜지스터를 1개만 사용해 뚜껑을 덮는다.
  * 버킷에 주기적으로 전자를 다시 채워 넣어야 한다. 즉, 가끔씩 메모리를 갱신해야 한다.
  * 집적도가 높아 큰 메모리 칩에 사용된다.
* SRAM과 DRAM은 휘발성 메모리이다.

### 읽기 전용 메모리(ROM)

* 정확히는 한 번만 쓸 수 있는 메모리(write-once memory)
* 과거에 천공 종이 테이프, 코어 로프 메모리(바느질을 통해서만 비트 기록 가능) 등 물리적으로 기록하는 방식을 사용했다.
* mask-programmable ROM, PROM(Programmable ROM), EPROM(erasable programmable ROM)을 거쳐 현재는 EEPROM(electrically EPROM)이 등장해 전기로 저장된 내용을 지울 수 있게 되었다.

## 블록 장치

* 디스크 드라이브 : 다른 유형의 메모리에 비해 상대적으로 느리지만 대용량의 데이터를 싼 가격에 저장할 수 있는 장치이다.
  * 디스크는 바이트 단위가 아닌 블록 단위로 주소를 지정해 읽는다.
  * 블록(섹터) : 디스크에서 읽고 쓰기가 가능한 가장 작은 단위로 보통 512바이트였으나 최근에는 4096바이트까지 저장한다.
  * 모든 섹터에 같은 수의 비트가 들어 있어서 비트 밀도는 각 원판의 바깥쪽보다 안쪽이 더 높다. 이러한 방식은 낭비가 심하기 때문에 최근에는 방사상 영역으로 구분해 외부 영역에 더 많은 섹터가 들어가도록 한다.
  * 탐색 시간(seek time) : 헤드를 한 트랙에서 다른 트랙으로 옮길 때 걸리는 시간
  * 회전 지연 시간(rotational latency) : 트랙 내에서 원하는 섹터가 헤드 아래로 올 때까지 디스크가 회전하는데 걸리는 시간
* 자기 드럼(magnetic drum) : 회전하는 원통에 헤드가 줄지어 있는 기억 장치
* 자기 테이프(magnetic tape) : 자화시킨 테이프를 감은 릴을 사용하는 장치
* 광학 디스크(optical disk) : 자기 디스크와 비슷하나 데이터를 읽고 쓰기 위해 자성 대신 빛을 사용하는 장치

## 플래시 메모리와 SSD

### 플래시 메모리

* 가장 최근에 나타난 EEPROM 유형의 매체로, 음악 플레이어나 디지털 카메라 등에 사용된다.
* DRAM처럼 버킷에 전자를 담는 방식으로 작동하나 버킷에서 전자가 새지 않는다.
* EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있다.
* 원하는 위치를 마음대로 읽을 수 있다.
* 빈 플래시 메모리에 데이터를 기록하려면 먼저 0을 채워 넣어야 한다. 
* 전체를 지우지 않고 원하는 비트만 0으로 되돌릴 수 없다. 
* 플래시 메모리 내부를 블록으로 나눠서, 블록 단위로 지우고 값을 쓸 수 있다.
* 읽을 때는 임의 접근 장치, 쓸 때는 블록 접근 장치다.

### SSD

* 고체 상태 드라이브(solid-state drive)로, 디스크 드라이브를 교체하고 있다.
* 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다.

## 오류 감지와 정정

### 패리티(parity)

* 단 1비트만 데이터가 잘못된 경우를 감지할 수 있다.
* 데이터에서 1로 설정된 비트의 개수를 센 뒤 그 개수가 짝수인지 홀수인지를 나타내는 1비트를 데이터에 덧붙인다. 이는 모든 비트의 XOR을 취하면 쉽게 만들 수 있다.
* 짝수 패리티는 모든 비트를 서로 XOR한 값을, 홀수 패리티는 XOR한 값의 보수를 사용한다.
* 오류가 짝수 번 발생한 경우를 감지하지 못한다는 문제점이 있다.
* 이를 활용한 해밍 코드는 더 많은 비트를 사용해 더 많은 오류를 감지할 수 있고 오류 횟수가 적은 경우에는 바로 수정할 수도 있다.

### 체크섬(checksum)

* 데이터의 각 지점을 n 비트값으로 더해서(n 비트를 넘어가는 값은 무시) 정적인 데이터 블록을 검증하는 방법
* n이 크면 클수록 위양성(false positive) 결과가 발생하기는 더 어려워진다.

### 순환 중복 검사(CRC)

* 데이터의 고유성을 충분히 드러낼 수 있는 방식으로 검증 숫자를 계산해서 데이터가 약간이라도 바뀌면 검증 숫자가 더 이상 일치하지 않게 만드는 것