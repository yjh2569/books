# 컴퓨터 내부 구조

## 메모리

* 컴퓨터 메모리 내에서 보통 1바이트마다 주소를 지정하지만, 한꺼번에 더 많은 데이터를 처리하기 위해 4바이트, 8바이트 단위로 주소를 지정하기도 한다.
* 따라서 데이터를 읽어올 때 여러 바이트들을 한꺼번에 데이터 버스에 담아 CPU로 전송한다.
* 이때 정렬이 맞지 않는 접근(nonaligned access)가 발생할 수 있다.
* 정렬이 맞지 않는 접근 : 한 번에 두 메모리 공간에 걸쳐 있는 데이터를 읽는 경우
> 4바이트 단위로 데이터를 읽어오는 컴퓨터에서 주소가 5, 6, 7, 8인 바이트를 사용하는 워드를 읽어오려면 5, 6, 7번 바이트를 담고 있는 1번 주소에서 한 번, 8번 바이트를 담고 있는 2번 주소에서 한 번 읽어서 총 2번 읽어와야 한다.
* 엔디안(endian) : 버스에 데이터를 담는 방식으로 프로세서에 따라 다르기에 시스템 간 데이터 전송 시 주의해야 한다.

## 입력과 출력

* 메모리 크기에 비해 설정할 수 있는 주소가 많기 때문에 I/O에 남은 주소를 할당하고, 이로 인해 I/O와 메모리가 같은 버스를 사용한다.
* 많은 컴퓨터에는 설계상 표준 I/O 슬롯(slot)이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다.

## 중앙 처리 장치(CPU)

### 산술 논리 장치(ALU)

* 산술 계산, 불리언 대수 및 기타 연산을 수행한다.
* 2개 이하의 피연산자(operand), 연산 코드(operation code)를 입력으로 받아 연산을 수행하고 결과와 조건 코드를 출력한다.
* 조건 코드는 결과에 대한 추가 정보가 들어간다. 조건 코드 레지스터에 조건 코드를 저장하는데, 연산 결과에 따라 N 비트(음수인 경우 1로 설정), Z 비트(0인 경우 1로 설정), O 비트(overflow나 underflow인 경우 1로 설정)을 포함한다.

### 시프트

* 왼쪽 시프트 : 모든 비트를 왼쪽으로 1비트씩 옮긴다. 맨 왼쪽 비트는 버리고, 맨 오른쪽 비트에 0을 넣는다. 보통 해당 수에 2를 곱한 것과 같다.
* 오른쪽 시프트 : 모든 비트를 오른쪽으로 1비트씩 옮긴다. 맨 오른쪽 비트는 버리고, 맨 왼쪽 비트에 0을 넣는다. 보통 해당 수를 2로 나누고 나머지를 버린 것과 같다.
* 시프트를 할 때 사라지는 MSB나 LSB는 필요한 경우 조건 레지스터의 O 비트에 저장한다.

### 실행 장치

* 메모리로부터 명령코드와 피연산자들을 가져와 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.
* 프로그램 저장 방식 컴퓨터(stored-program computer) : 실행 장치에게 제공하는 명령어를 메모리로부터 읽어오는 컴퓨터
* 명령어(instruction) : 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴으로 CPU마다 고유한 설계를 통해 만들어진다.
* 프로그램 카운터(PC) : 메모리에서 명령어를 가져와야 하는 위치를 알려주는 레지스터
* 보통 명령어를 순차적으로 수행한다고 가정하기에 명령어를 수행할 때마다 프로그램 카운터가 증가된다.

## 명령어 집합

### 명령어

* 3주소 명령어 : 명령어를 명령코드, 두 피연산자, 결과라는 네 가지 필드로 나눠서 구성한다. 피연산자들과 결과로 지정할 수 있는 주소값에 한계가 있고, 세 가지 메모리 위치를 한꺼번에 지정하기에 주소 버스와 데이터 버스를 3개씩 둬야 하는 비효율성 때문에 잘 사용하지 않는다.
* 따라서 ALU가 계산한 결과를 저장하는 레지스터인 누산기를 추가하고 명령어를 명령코드와 하나의 피연산자에 대한 주소로 나눠 구성한다. 단, 누산기에 있는 값을 메모리에 저장하는 저장 명령어를 추가해야 한다.

### 주소 지정 모드

* 직접 주소 지정 : 명령어에 들어있는 주소가 피연산자 주소인 경우
* 간접 주소 지정 : 명령어에 들어있는 주소가 피연산자 주소가 아니라 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소인 경우
* 즉시 주소 지정 모드 : 주소에 해당하는 비트를 그냥 값으로 간주한다.
> 메모리 주소 12에 4321이라는 값이 들어있고, 메모리 주소 4321에 345가 들어 있는 경우, 12를 피연산자로 해서 load 명령어를 수행하면 직접 주소 지정의 경우 누산기에 4321을, 간접 주소 지정의 경우 누산기에 345를, 즉시 주소 지정 모드의 경우 누산기에 12를 넣는다.

* 조건 코드 명령어 : 조건 코드를 원하는 값으로 설정하거나, 조건 코드의 값을 살펴볼 때 사용하는 명령어(cca, acc가 있다.)
* 분기 명령어 : 프로그램 카운터의 값을 변경할 수 있는 명령어로 조건 코드에 따라 조건을 만족하는 경우에만 분기하는 명령어도 존재한다.

* 최종적으로 명령어는 16비트 하에서 2비트의 주소 지정 모드, 4비트의 명령코드, 10비트의 주소로 이루어진다.

## 마지막 설계

* 명령어 레지스터 : 메모리에서 명령어를 가져온 뒤(페치(fetch)) 페치한 명령어에 편하게 접근할 수 있도록 명령어를 저장해두는 레지스터
* 간접 주소 레지스터 : 간접 주소 지정을 할 때 메모리에서 읽어온 주소를 저장하는 레지스터

## RISC와 CISC 명령어 집합

* RISC(reduced instruction set computer) : 복잡한 명령어를 단순한 명령어의 조합으로 처리함으로써 명령어의 수를 줄인 컴퓨터 ↔ CISC(complicated instruction set computer)
* RISC는 적재-저장 구조(load-store architecture)를 사용한다. 이 아키텍처는 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이뤄진 구조다.
* 최근에는 비디오나 오디오 처리를 위해 RISC 기계에 새로운 명령어를 추가해 오래전의 CISC 기계보다 훨씬 복잡하다.

## GPU

* 그래픽 처리를 위한 장치
* 일반적인 CPU에 비해 간단한 처리 장치가 아주 많이 들어 있고, 메모리 버스의 폭이 넓다.
* 최근에는 공학계산, 인공지능, 비트코인 채굴 등에도 쓰이고 있다.