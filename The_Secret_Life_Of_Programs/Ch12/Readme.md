# 병렬성과 비동기성

## 경합 조건

* 경합 조건(race condition) : 여러 프로그림이 같은 자원에 동시에 접근하고, 자원 사용 순서에 따라 결과가 달라지는 경우
* 경합 조건에서 자원은 여러 프로그램이 공유하기 때문에 공유 자원이라 한다.
> 공유 자원은 메모리, I/O 장치, FPGA(현장에서 프로그램 가능한 게이트 배열) 등에서 나타난다. 다른 컴퓨터상에서 실행되는 프로그램과의 통신에서도 공유 자원을 가질 수 있다.

## 프로세스와 스레드

* 프로세스 : 사용자 공간에서 실행되는 프로그램
* 멀티코어 시스템에서는 여러 프로그램이 병렬로 실행될 수 있다. 다만 경합 조건이 발생하려면 이 상황에서 프로그램들이 자원을 공유해야 한다.
* 자원을 공유하는 프로세스들은 어떤 방식으로든 서로 통신을 해야 한다. 프로그램에 코드 형태로 들어가거나, 어떤 설정 정보를 통해 통신 방식을 정한다.
* 스레드(thread) : 정적인 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분
* 각 소레드는 자신이 CPU 레지스터를 완전히 소유한다고 가정하기에 한 스레드에서 다른 스레드로 실행이 넘어갈 때 스레드 스케쥴러가 CPU 레지스터를 저장해야 한다.
* 스레드는 일반 프로세스보다 저장할 컨텍스트 크기가 훨씬 작기 때문에 프로세스 문맥 전환보다 스레드 문맥 전환이 빠르다.
* 스레드를 남용할 경우 오히려 좋지 않은 결과를 낳을 수 있다. 스레드는 데이터를 공유해 보안 문제가 생길 수 있고, 한 스레드에서 문제가 발생하면 프로세스 내 모든 스레드가 멈춰버린다.

## 락

* 여러 작은 연산으로 이뤄진 작업을 어떻게 원자적(atomic)으로 만들 수 있는지가 경합 조건을 해결하기 위한 중요한 문제다.
* 원자적 : 더 이상 나눌 수 없고 인터럽트할 수 없는 작업 단위
* 코드에서 중요한 부분을 상호 배제 메커니즘을 통해 원자적으로 처리하기 위해 락을 만든다.
* 초기에 나온 어드바이저리 락(advisory lock)은 락을 지킬지 안 지킬지를 프로그램이 결정하기에 강제성이 없어 문제가 발생할 수 있다. 따라서 운영체제에서 락을 관리한다.

### 트랜잭션과 작업 크기

* 트랜잭션 : 데이터베이스의 상태를 변화시키는 작업의 단위. 여러 연산을 하나의 트랜잭션으로 묶어 일부 연산만 수행되는 것을 막기 위해 도입되었다.
* 공유 자원에 대한 락을 거는 시간을 줄일수록 동시성을 늘릴 수 있다. 이를 위해 락을 거는 작업의 크기를 최소화해야 한다.
* 아주 작은 부분만 잠그는 락을 세밀하다(fine-grained)고 하고, 더 큰 범위를 잠그는 락을 성기다(coarse-grained)고 한다.

### 락 대기

* 락을 기다리는 동안 프로그램이 수행할 수 있는 유용한 작업이 없는 경우 스핀을 돌거나, 락을 관리하는 쪽에 락 획득 요청을 등록한 뒤 통지를 받는 방법이 있다.
  * 전자는 락을 성공적으로 얻을 때까지 락 획득을 반복 시도하는 것을 말한다. 이 경우 전력을 불필요하게 소모하고, 네트워크의 경우 트래픽을 증가시킬 수 있다.
  * 후자는 요청하는 쪽에서 기다리는 동안 더 유용한 일을 할 수 있다. 다만, 규모를 쉽게 키우기 어렵고, 인터넷 아키텍처에서는 직접적으로 지원되지 않는다.
* 일부 운영체제는 락 기능을 제공하는데, 블로킹이나 논블로킹 모드로 락을 요청할 수 있다.
  * 블로킹 : 시스템이 락을 할당할 수 있을 때까지 락을 요청한 프로그램을 일시중단(suspend)시킨다.
  * 논블로킹(non-blocking) : 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 어떤 방식으로든 통지받는다.

### 교착 상태

* 두 개 이상의 프로그램이 서로 원하는 락을 가지고 있어 모두 실행이 불가능한 상황
* 교착 상태는 상호 배제(mutual exclusion), 비선점(no preemption), 점유 대기(hold and wait), 순환 대기(circular wait) 조건을 동시에 만족하는 경우에만 발생한다.
* 따라서 네 가지 조건 중 하나라도 없으면 교착 상태가 발생하지 않기 때문에 다음과 같은 방법으로 이를 해소할 수 있다.
  * 자원을 상호 배제하지 않고 언제든 공유할 수 있는 자원으로 만든다.
  * 선점형으로 바꾼다.
  * 어느 자원을 점유한 다음 다른 자원을 요구하지 않고 한꺼번에 자원을 요구한다.
  * 자원마다 우선순위를 부여해 모든 프로세스가 서로 정해진 순서대로만 자원을 요구한다.

### 단기 락 구현

* 검사 후 설정(test and set) : 원자적 명령어로 어떤 메모리 위치에 들어있는 값을 1로 설정하고, 원래 그 위치에 들어있던 값을 돌려준다.
  * 두 개 이상의 프로세스가 명령어를 사용하면 한 프로세스의 검사 후 설정 명령어는 0을 반환하지만 나머지 프로세스의 검사 후 설정 명령어는 1을 반환한다. 즉, 0을 반환받은 프로세스에게만 락을 부여할 수 있다.
* 비교 후 바꾸기(compare and swap) : 검사 후 설정과 유사하나 한 값만 설정하는 대신 명령어를 호출하는 쪽에서 예전 값과 새 값을 모두 제공한다. 예전 값이 메모리 위치에 들어 있는 현재 값과 일치하면 메모리의 값을 새 값으로 바꾸고 락을 얻는다.
* 이런 명령어들은 시스템 모드에서만 사용할 수 있다.

### 장기 락 구현

* 여러 사용자가 같은 문서를 동시에 변경하는 것을 허용하지 않도록 하는 워드 프로세서와 같이 장기간 락을 필요로 하는 프로그램이 있다.
* 장기간 락은 메모리보다 좀 더 영구적인 저장소에 파일을 사용해 구현해 저장한다. 배타적으로 사용할 수 있는 파일을 생성하거나, 가장 먼저 요청한 프로세스가 성공하게 되는 시스템 콜이 있다.

## 브라우저 자바스크립트

* 멀티 스레드 환경을 고려하지 않고 설계된 언어이기 때문에 단일 스레드로 실행된다.
* 자바스크립트 구현은 이벤트 루프 모델을 사용한다.
* 이벤트 루프는 이벤트 큐에 실행할 작업을 하나씩 저장하고 큐에서 이벤트를 꺼내 코드를 실행하는 방식으로 이벤트들을 처리한다.
* 단일 스레드 프로그램이므로 이런 작업은 인터럽트할 수 없고, 이벤트가 큐에 추가되는 순서를 제어할 수 없다.
* 처음 등장했을 때는 비동기 통신을 언어 설계에 포함하지 않았으나, DOM, XHR(XMLHttpRequest) 등이 나오면서 웹 페이지 복잡도가 늘어났고, 이로 인해 웹 페이지가 서버와의 비동기 통신에 극도로 의존하게 됐다.
* jQuery의 post 함수를 통해 서버로 데이터를 요청할 경우 요청한 데이터가 오기 전에 그 데이터를 필요로 하는 다음 코드를 바로 실행하기 때문에 원하는 결과를 얻을 수 없는 문제가 발생한다.
* 따라서 이를 해결하려면 post의 응답이 온 뒤 처리하는 콜백 함수에서 해당 데이터를 필요로 하는 코드를 실행해야 한다. 다만 이러한 방식으로 처리하면 죽음의 피라미드, 혹은 콜백 헬에 빠질 수 있는 문제점이 존재한다.

## 비동기 함수와 프로미스

* 프로미스는 비동기 연산을 처리하는 라이브러리가 제대로 작동하도록 만들 수 있고, 프로그래밍 패러다임을 변화시킬 수 있는 편의 문법이다.
* 프로미스는 정의와 실행을 분리한다.
  * 정의할 때 비동기 연산을 수행하는 함수를 인자로 넘긴다. 이 함수는 두 인자로 resolve(비동기 연산이 성공적으로 종료하면 호출하는 함수), reject(비동기 연산이 실패하면 호출하는 함수)를 받는다. 프로미스에 넘기는 함수는 비동기 연산 수행 후 수행 성공이나 실패에 따라 resolve나 reject를 호출하면 자바스크립트가 이를 이벤트 큐에 넣어준다.
  * 실행할 때 then 메서드를 사용한다. then 메서드는 두 인자로 resolve가 이벤트 큐로 들어갔을 때 호출되는 함수와 reject가 이벤트 큐로 들어갔을 때 호출되는 함수를 받는다.
* 프로미스는 체이닝이 가능해 'something().then().then().then()...' 스타일의 코드를 작성할 수 있다. then 메서드가 다른 프로미스를 반환하기 때문이다.
* then의 두 번째 인자를 생략하고 예외 처리와 비슷하게 catch를 사용해 오류를 잡아낼 수도 있다.
* async와 await는 프로미스를 기반으로 만들었으나 동기적 코딩 스타일을 반영한다.
  * 비동기 함수 앞에 async를 붙이고 함수 내에서 순차적으로 처리해야 할 코드가 있으면 처리 코드(보통 메서드) 앞에 await를 붙인다.
