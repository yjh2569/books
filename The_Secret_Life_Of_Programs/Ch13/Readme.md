# 컴퓨터 보안

## 보안과 프라이버시 개요

### 위협 모델

* 보안이 필요한 대상 목록과 각 보안 대상에 가해질 수 있는 공격을 열거한 것
* 공격을 방어하는 방법을 설계할 수 있게 한다.
* 위협과 위협에 대비한 방어 사이에 균형을 맞추어야 한다.

### 신뢰

* 컴퓨터 보안 세계에서 신뢰는 선택할 수는 없지만 의존해야 하는 대상을 가리킨다. 결국 보안은 이런 구성요소의 보안에 달려 있다.
* 꼭 필요한 대상만으로 신뢰를 최소화해야 보안을 높일 수 있다.
> 컴퓨터를 사용할 경우 수많은 서드파티 하드웨어나 소프트웨어에 의존해야 한다. 이들의 하드웨어나 소프트웨어는 설계도나 소스 코드를 볼 수 없어 무조건 신뢰할 수 없지만, 결국 보안을 위해 이들에 의존하는 수밖에 없다.
  * 서드파티(third-party) : 컴퓨터를 만든 회사나 운영체제를 만든 회사가 아닌 그 밖의 회사들
* 신뢰 위반에는 여러 유형이 있다.
  * 의도적(deliberate) : 보안을 위한 구성요소를 제공할 때 의도적으로 악의적인 소프트웨어(멀웨어)를 넣을 수 있다.
  * 무능(incompetent) : 중요한 장치에 암호화 등 보안 요소를 추가하지 않거나 보안을 철저히 하지 않는 경우다. "잘못될 게 뭐 있겠어?"라는 위협 모델이 모호성에 의한 보안이라는 사고 방식과 어우러진 것에 기인한다.
  * 부정직(disingenuous) : 거짓말을 하는 경우다.
* 모호성에 의한 보안 : 비밀의 근원이 모호하면 보호 대상이 더 안전하다는 식의 주장으로, 실제로는 보안에 도움이 되지 않는다.
* 투명성과 개방성에서 더 나은 보안을 얻을 수 있다.
* 수천 개의 눈 원리 : 더 많은 사람이 현재 사용 중인 보안 기술에 대해 교육받고, 보안 기술의 약점에 대해 토의할수록 보안이 더 발전될 수 잇다.

### 물리적 보안

* 공격 표면(attack surface) : 보호 대상을 공격하는 사람의 타켓이 되는 지점
* 백도어(back-door) : 일반적인 보안 절차를 생략할 수 있는 통로

### 통신 보안

* 진본성(authenticity) : 대상이 위조, 변조되지 않음을 보장하는 것
* 통신 중 중간자 공격으로 인해 누가 전송을 처리할지, 전송을 보낸 사람을 인증하기 어려워질 수 있다.
* 크립토그래피(cryptography) : 암호화와 복호화를 통해 통신의 보안을 높이는 방법

### 모던 타임즈

* 서비스 거부 공격(DoS) : 정당한 고객들이 서비스를 받지 못하도록 방해하는 공격 방식. 현재는 분산 서비스 거부 공격(DDoS)으로 이루어진다.
  * 프록시를 사용해 다른 기계들이 공격을 하게 해 공격자 추격을 어렵게 한다.
* 공격에는 크립토그래피 시스템 공격과 사회적 공격이 있다.
  * 크립토그래피 시스템 공격은 상대적으로 드물고 잘 설계된 시스템을 공격하기 어렵다.
  * 사회적 공격은 트릭을 써서 사용자가 자신의 컴퓨터에 소프트웨어를 직접 설치하게 한다.
* 온갖 필수적인 인프라가 인터넷에 연결되어 있어 비트를 조작하면 물리적인 반향을 일으킬 수 있게 됐다.
* 딥페이크 기술을 통해 사실적인 사진, 오디오, 비디오를 만들기 매우 쉬워져 진본 판단이 어려워졌다.

### 메타데이터와 감시

* 통신 내용을 비밀로 해도 통신 패턴만으로 많은 정보를 얻을 수 있다.
* 메타데이터(metadata) : 데이터에 대한 데이터

### 인증과 권한부여

* 인증(authentication) : 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정
* 권한부여(authorization) : 제대로 된 자격증명을 제공하지 않는 사람에게 접근을 제한하는 것
* 많은 시스템에서 2단계 인증(2FA)을 사용한다. 여기서 단계(factor)는 독립적인 검증 수단을 말한다.
> 은행카드에 PIN을 입력하거나 패스워드를 입력하면 휴대전화로 일회용 코드를 보낼 수 있다.

## 크립토그래피

* 송신자가 통신 내용을 암호화해 정해진 수신자만 디코딩하도록 송신할 수 있다.
* 보안과 프라이버시뿐만 아니라 암호 서명을 사용해 데이터의 진실성을 증명할 수 잇다.

### 스테가노그래피(steganography)

* 어떤 내용을 다른 내용에 감추는 방식
* 기술적으로는 크립토그래피가 아니지만 암호화와 거의 비슷하게 부합한다.

### 치환 암호

* 각 문자를 다른 문자로 변환하는 표를 만들어 메시지를 표를 참조해 암호화하거나 복호화하는 방식
* 암호화와 복호화에 같은 암호를 사용하기에 대칭 코드라 부른다.
* 통계를 사용하면 쉽게 깰 수 있는 암호라 보안성이 낮다.

### 전치 암호

* 문자 위치를 뒤섞는 방식
* 컴퓨터를 사용해 여러 격자 크기를 테스트할 수 있기에 아주 쉽게 풀 수 있다.

### 일회용 패드

* 중복되지 않는 유일한 치환 암호들의 모음으로 각 치환 암호 코드를 단 한 번만 사용했다.
* 원래 메시지의 각 글자와 패드의 각 글자를 1부터 26 사이의 숫자로 보고 두 숫자를 더한(암호화할 때, 복호화할 때는 뺀다) 결과를 다시 문자로 치환하는 방식을 사용했다.
* 하지만 양 당사자가 똑같은 패드를 써야 하고, 서로 동기화돼야 하며, 패턴 반복을 피하기 위해서는 패드가 메시지만큼 길어야 한다는 단점이 있다.

### 공개키 암호

* 대칭 암호 시스템은 근본적으로 양 당사자가 같은 키를 사용해야 한다는 문제점이 있다. 따라서 키를 전달하는 과정에서 중간자 공격에 취약하다.
* 공개키 암호는 대칭키 암호의 문제를 해결하기 위해 공개키와 비밀키로 키 쌍을 만들어 사용한다.
  * 공개키(public key) : 누구에게나 알려져 있는 키
  * 비밀키(private key) : 자기 자신만 알고 있어야 하는 키
* 암호화와 복호화에 사용하는 키가 다르기 때문에 비대칭 시스템이다.
* 공개키 암호는 트랩도어 함수에 의존한다. 즉, 트랩도어 함수로 계산할 수 있는 정보는 공개키로, 트랩도어 함수를 쉽게 풀 수 있게 해주는 비밀 정보는 비밀키로 사용한다.
  * 트랩도어 함수 : 한 방향으로는 계산이 간단하나 다른 방향으로는 비밀 정보를 알지 못하면 계산이 어려운 함수
* 디피-헬먼 키 교환(DHKE) : 비밀리에 메시지 내용을 실제로 암호화할 때 사용할 대칭 세션 키를 만들어내는 방법으로 비대칭 암호화를 사용한다.
* 대칭 세션 키는 실제 통신에서 키를 발견하면 모든 메시지를 읽을 수 있다는 단점이 존재하는데, 이를 피하는 방법이 전방향 안전성이다. 전방향 안전성 암호화는 각 메시지마다 세션 키를 새로 만들어 키를 알아내도 메시지를 단 하나만 풀 수 있게 된다.

### 암호학적 해시 함수

* 단방향 함수로 입력에서 해시값을 만들기는 쉽지만 입력을 만들어내는 것은 거의 불가능하다.
* 차이가 조금 있는 여러 입력 데이터에 대응하는 해시값들이 서로 연관관계가 없어야 한다.
* 도용하기 어렵게 함으로써 해시값가 주어져도 해시값를 만들어내는 입력 데이터를 알아내기 어려워야 한다.
* MD5 해시 함수가 가장 널리 쓰였으나 충돌을 만들어내는 방법이 발견되어 SHA 알고리즘을 변형한 다른 해시 알고리즘이 MD5 대신 쓰이고 있다.

### 디지털 서명

* 데이터가 진본임을 검증하는데 쓰인다.
* 암호화 및 복호화 때와 달리 송신자가 자신의 비밀키를, 수신자가 송신자의 공개키를 사용한다.
* 정합성, 부인방지, 인증을 제공한다.
  * 정합성(integrity) : 메시지가 변조됐는지 검증할 수 있다. 암호학적 해시값을 계산해 데이터 뒤에 추가함으로써 이뤄진다.
  * 부인방지(nonrepudiation) : 메시지를 보낸 사람이 자기가 그런 메시지를 보낸 적이 없다고 주장할 수 없다. 송신자가 비밀키로 메시지에 서명을 하기 때문이다.
  * 인증(authentication) : 정합성과 부인방지를 통해 수신자가 받은 메시지가 송신자가 보낸 변조되지 않은 메시지임을 확인하는 것

### 공개키 인프라

* 보통 공개키는 브라우저가 전달하는데, 실제로 브라우저가 공개키를 제대로 전달한 건지 신뢰하기 어렵다.
* 공개키 인프라스트럭처(PKI, public key infrastructure) : 신뢰할 수 있는 제3자인 인증기관(CA, certificate authority)이 있어서 키가 어떤 당사자의 것임을 인증해준다.
* 인증기관이 키를 발행할 기관을 확실히 알고, 키가 그 기관의 키임을 인증하기 위해 인증기관의 키로 서명된 인증서를 발행해준다.

### 블록체인

* 여러 개의 블록이 이전 블록의 해시와 블록 생성 시간(타임스탬프)으로 연결되어 생성된 체인
* 일부 블록의 내용을 변경하면 그 블록의 해시가 바뀌어 다음 블록에 저장된 해시와 일치하지 않게 된다. 따라서 각 블록이 해시를 유지하면서 쓸모 있게 블록 정보를 변조할 수 있는 가능성은 거의 없다.
* 블록체인을 공격하려면 블록체인을 다루는 소프트웨어를 변경하는 방법뿐인데, 블록체인 데이터가 공개되어 있고 수없이 많은 시스템에 중복되어 있어 변형된 소프트웨어의 영향을 경감시킬 수 있다.

### 패스워드 관리

* 기존에는 패스워드 파일에 패스워드를 평문으로 저장했었다. 이는 누군가 패스워드 파일에 접근하면 보안이 쉽게 깨질 수 있기에 좋은 방법이 아니었다.
* 이를 해결하기 위해 패스워드를 암호학적 해시와 같은 암호학적 해시와 같은 암호화된 형태로 저장하고, 로그인을 시도하면 패스워드를 암호학적 해시로 변환해 파일에 있는 해시와 비교하는 방식을 사용했다.

## 보안을 위한 소프트웨어 예방조치

* 올바른 대상을 보호하라 : 모든 대상을 보호하는 것이 아닌, 정말 보호해야 하는 대상들만 보호한다.
* 로직은 세 번 체크하라
* 오류를 검사하라
* 공격 표면을 최소화하라
* 경계 내부에 머물러라 : 데이터의 메모리 경계를 넘어갈 수 있으면 보안 문제가 발생할 수 있다.
* 좋은 난수를 생성하기는 힘들다 : 가장 흔히 쓰이는 난수 생성기는 실제로는 의사 난수를 생성하는데, 같은 숫자에서 시작하면 같은 순서로 난수가 생성된다. 논리 회로로는 난수를 만들 수 없기 때문이다. 최근에는 여러 대상으로부터 엔트로피를 수집하는 방법으로 난수를 생성하고 있다.
* 네 코드를 알라 : 큰 프로젝트에는 서드파티 코드가 들어가는 경우가 자주 있는데, 이로 인해 문제가 발생할 수도 있기 때문에 오픈소스 코드를 사용하거나, 제3자 패키지에서 실제로 사용하는 코드의 크기와 전체 패키지 크기 사이의 비율을 주시한다.
* 극단적인 영리함은 여러분의 적이다 : 서드파티 코드를 사용할 때 잘 사용하지 않는 기능은 피해야 한다. 서드파티 코드를 업그레이드할 때 문제가 발생할 수도 있다.
* 눈에 보이는 것을 이해해라 : 사이드 채널 공격(메타데이터나 부작용에 기반을 둔 공격 방법)에 주의를 기울여야 한다. 중요한 보안 코드에 대해 외부에서 관찰할 수 있는 행동이 실제 내부에서 일어나고 있는 일과 무관해야 한다.
* 과다수집하지 마라 : 정말 필요한 경우가 아니라면 민감한 정보를 수집하지 않는다.
* 모아두지 마라 : 가능하면 빨리 민감한 정보를 없앤다.
* 동적 메모리 할당은 여러분의 친구가 아니다 : 메모리 해제 전 혹은 메모리를 줄이는 경우 그에 따라 반환될 영역에 있는 정보를 지워야 하고, 보안이 필수적인 경우 realloc(할당된 메모리의 크기를 줄이거나 늘리는 함수)를 사용하면 안 된다.
* 가비지 컬렉션은 여러분의 친구가 아니다 : 가비지 컬렉션은 사용이 끝난 민감한 정보를 모두 처리하지는 못한다. 명시적인 메모리 관리 대신 가비지 컬렉션을 사용하는 언어의 경우, 민감한 정보를 덮어쓰는 대신 새로운 문자열을 할당하고 민감한 정보가 담긴 문자열은 가비지 컬렉션이 가능한 문자열로 분류한다. 이를 강제로 지우는 방법은 없다.
* 코드 역할을 하는 데이터 : 메모리 관리 장치나 하버드 아키텍처 가계는 코드와 데이터를 분리해서 데이터 실행을 막지만, 데이터를 실행할 수 있는 프로그램은 직접 이런 보호를 제공해야 한다. SQL 주입이 대표적인 예시 중 하나다. 쿼리 내 변수에 문자열을 전달할 때 SQL 문법에 적절히 맞춰 추가 쿼리를 보내면 해당 추가 쿼리와 합해서 쿼리문을 수행한다.

 