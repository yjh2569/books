# 스프링 DI

## 의존

* 의존 : 객체 간의 의존을 의미한다.
  * 한 클래스가 다른 클래스의 메서드를 실행할 때 이를 의존한다고 표현한다.
  * 변경에 의해 영향을 받는 관계를 의미한다고도 할 수 있다.
  
* 의존하는 대상을 구하는 방법
  * 가장 쉬운 방법은 의존 대상 객체를 직접 생성하는 것이다.
  * 이렇게 하면 클래스의 객체를 생성할 때 의존하는 클래스의 객체도 함께 생성된다.
  * 다만 이렇게 하면 유지보수 관점에서 문제점을 유발할 수 있다.
  * 이를 해결하기 위해 DI 혹은 서비스 로케이터를 통해 의존 객체를 구하는 방법이 있다.
  * 스프링에서는 DI를 이용해 의존 객체를 구한다.
  
## DI를 통한 의존 처리

* DI는 의존하는 객체를 직접 생성하는 대신 의존 객체를 전달받는 방식을 사용한다.
  * 생성자를 통해 의존 객체를 전달받음으로써 의존 객체를 주입받는다.

> MemberRegisterService 클래스에 DI 방식을 적용한 경우
```
public MemberRegisterService(MemberDao memberDao) {
    this.memberDao = memberDao;
}

// 객체 생성시 다음과 같이 MemberDao 객체를 전달해야 한다.
MemberDao dao = new MemberDao();
MemberRegisterService svc = new MemberRegisterService(dao);
```

## DI와 의존 객체 변경의 유연함

* 의존 객체를 직접 생성하는 경우
  * MemberRegisterService와 ChangePasswordService가 MemberDao 의존 객체를 직접 생성한다고 가정한다.
  * 만약 회원 데이터의 빠른 조회를 위해 MemberDao를 상속한 CachedMemberDao 클래스를 새로 만들었다고 할 때 이를 사용하려면 MemberRegisterService와 ChangePasswordService 클래스의 코드에서 MemberDao 클래스의 생성자가 아닌 CachedMemberDao 클래스의 생성자를 호출하도록 변경해야 한다.
  
* 위와 동일한 상황에서 DI를 사용하면 수정할 코드가 줄어든다.
  * 생성자를 통해 의존 객체를 주입받도록 구현한다면, MemberDao 대신 CachedMemberDao를 사용하도록 수정할 때 MemberDao 객체를 생성하는 코드만 변경하면 된다. 따라서 변경할 코드가 한 곳에 집중된다.
  
## 객체 조립기

* 실제 객체를 생성할 때 main 메서드에서 객체를 생성해도 되지만, 객체를 생성하고 의존 객체를 주입해주는 클래스를 따로 작성하는 것이 좋다.
  * 이러한 클래스를 조립기(assembler)라고 한다.
  
## 스프링의 DI 설정

* 스프링은 앞서 구현한 조립기와 유사한 기능을 제공한다.

* 주로 발생하는 에러
  * NoSuchBeanDefinitionException이 발생한다.
  * 빈 설정 메서드에 @Bean을 붙이지 않은 경우
  * @Bean 설정 메서드의 이름과 getBean() 메서드에 전달한 이름이 다른 경우
  
### DI 방식

* 생성자 방식
  * 빈 객체를 생성하는 시점에 모든 의존 객체가 주입된다.
  * 생성자의 파라미터 개수가 많으면 각 인자가 어떤 의존 객체를 설정하는지 생성자의 코드를 확인해야 한다.
* setter 메서드 방식
  * setter 메서드 이름을 통해 어떤 의존 객체가 주입되는지 알 수 있다.
  * 필요한 모든 의존 객체에 대한 setter 메서드를 직접 호출해야 하고, 만약 하나라도 빼 먹으면 NullPointerException이 발생할 수 있다.
  
## @Configuration 설정 클래스의 @Bean 설정과 싱글톤

* 스프링 컨테이너는 @Bean이 붙은 메서드에 대해 한 개의 객체만 생성한다.
  * 즉, 다른 설정 메서드에서 memberDao()를 몇 번을 호출하더라도 항상 같은 객체를 리턴한다.
  
* 스프링은 설정 클래스를 그대로 사용하지 않고 이를 상속한 새로운 설정 클래스를 만들어 사용한다.
  * 스프링에 런타임에 생성한 설정 클래스는 한 번 생성한 객체를 보관했다가 이후에는 동일한 객체를 리턴한다.
  
## 두 개 이상의 설정 파일 사용하기

* @Autowired
  * 스프링의 자동 주입 기능을 위한 애노테이션이다.
  * 스프링 설정 클래스의 필드에 @Autowired 애노테이션을 붙이면 해당 타입의 빈을 찾아서 필드에 할당한다.
  * @Autowired를 통해 다른 설정 파일에 정의한 빈을 필드에 할당했다면 설정 메서드에서 이 필드를 사용해서 필요한 빈에 주입하면 된다.

* 설정 클래스가 두 개 이상인 경우 AnnotationConfigApplicationContext에 인자로 설정 클래스를 여러 개 전달하면 된다.
  * 생성자의 인자는 가변 인자이기 때문이다.

```
ctx = new AnnotationConfigApplicationContext(AppConf1.class, AppConf2.class);
```

* 스프링은 @Configuration 애노테이션이 붙은 설정 클래스를 내부적으로 스프링 빈으로 등록한다.
  * 그리고 다른 빈과 마찬가지로 @Autowired가 붙은 대상에 대해 알맞은 빈을 자동으로 주입한다.
  
* 두 개 이상의 설정파일을 사용하는 또 다른 방법은 @Import 애노테이션을 사용하는 것이다.
  * @Import 애노테이션은 함께 사용할 설정 클래스를 지정한다.
  * 이 애노테이션을 통해 지정한 설정 클래스도 함께 사용하기 때문에 스프링 컨테이너를 생성할 때 해당 설정 클래스를 지정할 필요가 없다.
  * @Import( { AppConf1.class, AppConf2.class } )와 같이 배열을 이용해 두 개 이상의 설정 클래스도 지정할 수 있다.
  * 이를 활용하면 사용하는 설정 클래스가 추가되어도 Main 클래스를 수정할 필요가 없다. AnnotationConfigApplicationContext를 생성하는 코드는 최상위 설정 클래스 한 개만 사용하고, 최상위 설정 클래스만 변경하면 된다.
  
## getBean() 메서드 사용

* 지금까지 사용한 getBean() 메서드의 첫 번째 인자는 빈의 이름, 두 번째 인자는 빈의 타입이다.
  * 존재하지 않는 빈 이름을 사용하면 NoSuchBeanDefinitionException이 발생하므로 주의해야 한다.
  * 빈의 실제 타입과 getBean() 메서드에 지정한 타입이 다르면 BeanNotOfRequiredTypeException이 발생한다.
  
* 빈 이름을 지정하지 않고 타입만으로 빈을 구할 수도 있다.
  * 해당 타입의 빈 객체가 한 개만 존재하면 해당 빈을 구해서 리턴한다.
  * 해당 타입의 빈 객체가 존재하지 않으면 NoSuchBeanDefinitionException이 발생한다.
  * 같은 타입의 빈 객체가 두 개 이상 존재하면 NoUniqueBeanDefinitionException이 발생한다.
  
## 주입 대상 객체를 모두 빈 객체로 설정해야 하나?

* 주입할 객체가 꼭 스프링 빈이어야 할 필요는 없다.
  * 빈으로 등록하지 않고 일반 객체로 생성해서 주입해도 된다.
  * 다만 스프링 컨테이너가 객체를 관리하지 않기에 스프링 컨테이너에서 해당 객체를 구할 수 없다.
  * 또한 스프링 컨테이너는 자동 주입, 라이프사이클 관리 등 단순 객체 생성 외에 객체 관리를 위한 다양한 기능을 제공하는데 이러한 기능을 이용할 수 없다.
  
* 최근에는 의존 자동 주입 기능을 프로젝트 전반에 걸쳐 사용하는 추세이기 때문에 의존 주입 대상은 보통 스프링 빈으로 등록한다.