# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

* 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  * 클래스 API로 공개된 메서드 안에서 클래스 자신의 또 다른 메서드를 호출할 수 있는데, 그 메서드가 재정의 가능하다면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다.
  * 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.
  * 재정의 가능한 메서드는 public과 protected 메서드 중 final이 아닌 모든 메서드를 말한다.
  * 즉, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
  
* API의 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
  * 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다.
  
* 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
> List 구현체의 최종 사용자는 removeRange(특정 범위 내 배열의 원소들을 제거하는 메서드)가 필요없지만, 하위 클래스에서 부분 리스트의 clear 메서드를 고성능으로 만들기 위해서는 removeRange 메서드가 필요하기 때문에 이를 protected 메서드로 공개하고 있다.

* 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

* 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
  * 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되는데, 재정의된 메서드가 상위 클래스의 생성자 안에 있으면 이를 하위 클래스의 생성자보다 먼저 호출하게 된다. 이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.
  
```
public class Super {
    // 잘못된 예 : 생성자가 재정의 가능 메서드를 호출한다.
    public Super() {
        overrideMe();
    }
    
    public void overrideMe() {}
}

public final class Sub extends Super {
    // 초기화되지 않은 final 필드. 생성자에서 초기화한다.
    private final Instant instant;
    
    Sub() {
        instant = Instant.now();
    }
    
    // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
    @Override
    public void overrideMe() {
        System.out.println(instant);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

* 위 예시에서 instant를 두 번 출력하리라 기대하지만, 실제로는 첫 번째에서 null을 출력하게 된다. 상위 클래스의 생성자를 호출할 때는 instant가 아직 초기화되지 않은 상태이기 때문이다. 즉, final 필드의 상태가 두 가지가 된다.

* private, final, static 메서드는 재정의가 불가능하기 때문에 생성자에서 안심하고 호출해도 된다.

* Clonable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다.
  * clone과 readObject는 새로운 객체를 만들기 때문에 생성자와 비슷한 효과를 낸다. 따라서 이들을 구현할 때 따르는 제약도 재정의 가능 메서드를 호출해서는 안 된다는 점이다.
  * Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다.

* 일반적인 구체 클래스의 경우 상속용으로 설계하지 않은 경우가 많은데, 그렇기 때문에 상속을 미리 금지시켜 놓는 것이 좋다.
  * 클래스를 final로 선언하거나, 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩토리를 만들어준다.
  * 상속을 꼭 허용해야겠다면 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남긴다. 즉, 재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽히 제거한다.
  * 클래스의 기존 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 재거하는 기계적인 방법이 있다. 각각의 재정의 가능 메서드는 자신의 본문 코드를 private 도우미 메서드로 옮기고, 이 도우미 메서드를 호출하도록 수정한다. 그리고 재정의 가능 메서드를 호출하는 다른 코드들이 모두 이 도우미 메서드를 호출하도록 수정한다.