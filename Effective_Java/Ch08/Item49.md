# 매개변수가 유효한지 검사하라

* 메서드와 생성자 대부분은 입력 매개변수 값이 특정 조건을 만족하기를 바란다.
  * 이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.

* 매개변수 검사를 제대로 하지 못할 경우 발생할 수 있는 문제
  * 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
  * 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
  * 메서드는 문제없이 수행되지만 어떤 객체를 이상한 상태로 만들어 미래의 알 수 없는 시점에 이 메서드와 관련 없는 오류를 낼 수 있다.
  * 즉, 매개변수 검사에 실패하면 최악의 경우 실패 원자성을 어기는 결과가 나올 수 있다.
  
* public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.
  * @throws 자바독 태그를 사용하면 된다.
  * 매개변수 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
  
> 메서드 작성의 전형적인 예시
```
/**
 * (현재 값 mod m) 값을 반환한다. 이 메서드는
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
 * 
 * @param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0) {
        throw new ArithmeticException("계수(m)는 양수여야 합니다. "+m);
    }
    ... // 계산 수행
}
```

* 위 메서드는 m이 null이면 m.signum() 호출 시 NullPointerException을 던지지만 이 설명은 BigInteger 클래스 수준에서 기술했기 때문에 각 메서드에 일일이 기술할 필요는 없다.
  * 자바 7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다. 원하는 예외 메시지도 지정할 수 있다. 또한 입력을 그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행할 수 있다.
  
> requireNonNull 사용 예시
```
this.strategy = Objects.requireNonNull(strategy, "전략");
```

* 자바 9에서는 Objects에 범위 검사 기능도 더해졌다.
  * checkFromIndexSize, checkFromToIndex, checkIndex가 이러한 기능을 담당하는 메서드들이다.
  * null 검사 메서드만큼 유연하지는 않다. 예외 메시지를 지정할 수 없고, 리스트와 배열 전용으로 설계됐다. 또한 닫힌 범위(양 끝단을 포함하는)는 다루지 못한다.

* public이 아닌 메서드라면 단언문(assert)를 사용해 매개변수 유효성을 검증할 수 있다.
  * 메서드가 포함된 패키지를 클라이언트가 어떤 식으로 사용하는지와 상관없이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다.
  * 실패하면 AssertionError를 던진다.
  * 런타임에 아무런 효과도, 아무런 성능 저하도 없다.

> 재귀 정렬용 private 도우미 함수
```
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
}
```

* 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
  * 정적 팩토리 메서드가 int 배열의 List를 반환하는 메서드인데, 만약 List가 null인 경우를 검사하지 않는다면 해당 List를 사용하려 할 때 NullPointerException이 발생한다.
  * 생성자는 이러한 원칙의 특수한 사례다. 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는데 꼭 필요하다.
  
* 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 또는 계산 과정에서 암묵적으로 검사가 수행되면 매개변수 유효성을 검사하지 않는다.
> Collections.sort(List)는 리스트 안의 객체들이 모두 상호 비교될 수 있어야 한다는 조건이 필요한데, 이에 대한 유효성을 검사하려면 모든 객체가 상호 비교될 수 있는지 검사해야 한다. 하지만 이는 별다른 실익이 없다.

* 때로는 계산 과정에서 필요한 유효성 검사가 이뤄지지만 실패했을 때 잘못된 예외를 던지기도 한다.
  * 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다.
  * 이런 경우 예외 번역 관용구를 사용해 API 문서에 기재된 예외로 번역해줘야 한다.
  
* 그렇다고 매개변수에 제약을 두는 것이 좋은 것은 아니다.
  * 메서드는 최대한 범용적으로 설계해야 한다.
  * 메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약을 적을수록 좋다.