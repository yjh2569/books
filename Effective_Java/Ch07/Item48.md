# 스트림 병렬화는 주의해서 적용하라

* 자바는 동시성 프로그래밍을 지원한다.
  * 처음에는 스레드, 동기화, wait/notify를 지원했다.
  * 자바 5부터는 동시성 컬렉션인 java.util.concurrent 라이브러리와 실행자(Executor) 프레임워크를 지원했다.
  * 자바 7부터는 고성능 병렬 분해 프레임워크인 포크-조인(fork-join) 패키지를 추가했다.
  * 자바 8부터는 parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 스트림을 지원했다.
  * 하지만 동시성 프로그래밍을 할 때는 안전성과 응답 가능 상태를 유지하도록 노력해야 한다.
  
* 데이터 소스가 Stream.iterate거나 중간 연산으로 limit을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.
  * limit을 다룰 때 파이프라인 병렬화는 CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정하는데, 만약 제한된 개수 이후의 연산이 오래 걸릴 경우 오히려 계산 시간이 평소보다 더 걸릴 수 있다.
  
* 대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.
  * 이 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 다수의 스레드에 분배하기에 좋다.
  * 또한 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있어 참조 지역성이 뛰어나다. 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 아주 중요한 요소로 작용한다. 하지만 참조들이 가리키는 실제 객체가 메모리에서 서로 떨어져 있는 경우에는 참조 지역성이 나빠진다.
  * 나누는 작업은 Spliterator가 담당하며, Spliterator 객체는 Stream이나 Iterable의 spliterator 메서드로 얻어올 수 있다.

* 스트림 파이프라인의 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 준다.
  * 종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)다.
  * 축소 : 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업
  > Stream의 reduce 메서드 중 하나, 혹은 min, max, count, sum 같이 완성된 형태로 제공되는 메서드 중 하나를 선택해 수행한다.
  * anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합하다.
  * 반면, 가변 축소(mutable reduction)을 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다. 컬렉션들을 합치는 부담이 크기 떄문이다.
  
* 직접 구현한 Stream, Iterable, Collection이 병렬화의 이점을 제대로 누리게 하고 싶으면 spliterator 메서드를 반드시 재정의하고 결과 스트림의 병렬화 성능을 강도 높게 테스트해야 한다.

* 스트림을 잘못 병렬화하면 응답 불가를 포함해 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
  * 안전 실패 : 결과가 잘못되거나 오동작하는 것
  * 안전 실패는 병렬화한 파이프라인이 사용하는 mappers, filters, 혹은 프로그래머가 제공한 다른 함수 객체가 명세대로 동작하지 않을 때 벌어질 수 있다.
  > Stream의 reduce 연산에 건네지는 accumulator와 combiner 함수는 반드시 결합법칙을 만족하고, 간섭받지 않고(파이프라인 수행 중 데이터 소스가 변경되지 않아야 함), 상태를 갖지 않아야 한다.
  * 병렬화 결과를 출력되는 순서가 올바르지 않을 수 있는데, 이는 종단 연산 forEach를 forEachOrdered로 바꿔주면 된다.
  
* 스트림 병렬화는 오직 성능 최적화 수단으로, 변경 전후로 반드시 성능을 테스트해 병렬화를 사용할 가치가 있는지 확인해야 한다.
  * 보통 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 실행되므로 잘못된 파이프라인 하나가 시스템의 다른 부분의 성능에까지 악영향을 줄 수 있다.
  
* 조건이 잘 갖춰지기만 하면 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다.
  * 머신러닝과 데이터 처리 같은 특정 분야에서 활용될 만 하다.
  
* 무작위 수들로 이뤄진 스트림을 병렬화할 경우 SplittableRandom 인스턴스를 사용한다.
  * ThreadLocalRandom은 단일 스레드에서 쓰고자 만들어졌고, Random은 모든 연산을 동기화하기 때문에 병렬 처리하면 최악의 성능을 보인다.